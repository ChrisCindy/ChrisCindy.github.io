<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[采用gulp优化本博客打开速度]]></title>
      <url>http://chriscindy.top/2016/08/22/%E9%87%87%E7%94%A8gulp%E4%BC%98%E5%8C%96%E6%9C%AC%E5%8D%9A%E5%AE%A2%E6%89%93%E5%BC%80%E9%80%9F%E5%BA%A6/</url>
      <content type="html"><![CDATA[<p>博客搭建这么久了发现并没有进行过优化，首页虽然打开速度勉强能够接受，但是 github 和 coding 提供的空间有限，是时候优化一下了。基本思路是采用 gulp 进行代码的压缩等。先占个坑，等最近有空搞一下。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[babel-rigster和babel-node的使用]]></title>
      <url>http://chriscindy.top/2016/08/22/babel-rigster%E5%92%8Cbabel-node%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>Babel 6 中 <code>babel-register</code> 和 <code>babel-node</code> 两个模块是开发时非常好用的转码工具。先来看一下如何使用：</p>
<h4 id="1-babel-register"><a href="#1-babel-register" class="headerlink" title="1. babel-register"></a>1. babel-register</h4><ul>
<li><p>安装：<code>npm install babel-register</code></p>
</li>
<li><p>作用：<code>babel-register</code> 实际上为<code>require</code>加了一个钩子（hook），之后所有被 node 引用的 <code>.es6</code>、<code>.es</code>、<code>.jsx</code> 以及 <code>.js</code> 文件都会先被 Babel 转码。</p>
</li>
<li><p>使用示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//index.js</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//register.js</span></div><div class="line"><span class="built_in">require</span>(<span class="string">"babel-register"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"./index.js"</span>);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node register.js</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-babel-node"><a href="#2-babel-node" class="headerlink" title="2. babel-node"></a>2. babel-node</h4><ul>
<li><p>安装：<code>npm install babel-node</code></p>
</li>
<li><p>作用：替代 CLI 中的 <code>node</code> 命令，可以直接运行采用 ES6 语法编写的代码。</p>
</li>
<li><p>使用示例：</p>
<ul>
<li><p>在 npm <code>scripts</code> 中：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  "scripts": &#123;</div><div class="line">    //"script-name": "node main.js"</div><div class="line">    "script-name": "babel-node main.js"</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在命令行中：</p>
<ul>
<li>全局安装 <code>babel-node</code>：<code>babel-node main.js</code></li>
<li>本地安装 <code>babel-node</code>：<code>./node_modules/.bin/babel-node main.js</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-使用局限"><a href="#3-使用局限" class="headerlink" title="3. 使用局限"></a>3. 使用局限</h4><p>尽管 <code>babel-register</code> 和 <code>babel-node</code> 都非常好用，但是由于二者都是实时转码，因而性能上会有一定影响。官方建议将二者仅置于开发环境下使用。而在正式生产环境中部署时，预先编译代码是值得推荐的做法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Babel 6 特性总结]]></title>
      <url>http://chriscindy.top/2016/08/22/Babel-6-%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h3 id="0-改进"><a href="#0-改进" class="headerlink" title="0. 改进"></a>0. 改进</h3><ul>
<li><p>模块化</p>
</li>
<li><p>可选的插件</p>
</li>
<li><p>预设</p>
</li>
<li><p>性能改进</p>
</li>
<li><p>插件 API</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Babel 5</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"> &#123;Plugin, types: t&#125; </span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Plugin(<span class="string">'ast-transform'</span>, &#123;</div><div class="line">        visitor: &#123; ... &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">                      </div><div class="line"><span class="comment">// Babel 6</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"> &#123; types: t&#125; </span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        visitor: &#123; ... &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-安装-Babel-6"><a href="#1-安装-Babel-6" class="headerlink" title="1.安装 Babel 6"></a>1.安装 Babel 6</h3><p><code>npm install</code></p>
<ul>
<li><p><strong>babel-cli</strong></p>
<ul>
<li><p>usage:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">babel app.js</div></pre></td></tr></table></figure>
</li>
<li><p>command: </p>
<ul>
<li>-o –out-file</li>
<li>-d –out-dir</li>
<li>-w –watch</li>
<li>–source-maps</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>babel-register</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//index.js</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//register.js</span></div><div class="line"><span class="built_in">require</span>(<span class="string">"babel-register"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"./index.js"</span>);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node register.js</div></pre></td></tr></table></figure>
<p>注：生产环境不适用 </p>
</li>
<li><p><strong>babel-node</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  "scripts": &#123;</div><div class="line">    //"script-name": "node index.js"</div><div class="line">    "script-name": "babel-node index.js"</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>command:</p>
<ul>
<li>–presets</li>
<li>–plugins</li>
<li>–ignore</li>
</ul>
<p>注：生产环境不适用 </p>
</li>
<li><p><strong>babel-core</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">"babel-core"</span>);</div><div class="line"></div><div class="line">babel.transform(<span class="string">"code();"</span>, options);</div><div class="line"><span class="comment">// =&gt; &#123; code, map, ast &#125;</span></div><div class="line"></div><div class="line">babel.transformFile(<span class="string">"filename.js"</span>, options, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</div><div class="line">  result; <span class="comment">// =&gt; &#123; code, map, ast &#125;</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">babel.transformFileSync(<span class="string">"filename.js"</span>, options);</div><div class="line"><span class="comment">// =&gt; &#123; code, map, ast &#125;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-配置-Babel-6"><a href="#2-配置-Babel-6" class="headerlink" title="2. 配置 Babel 6"></a>2. 配置 Babel 6</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//.babelrc</div><div class="line"></div><div class="line">&#123;</div><div class="line">  "presets": [],</div><div class="line">  "plugins": []</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//or package.json</div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  "babel":&#123;</div><div class="line">    "presets": [],</div><div class="line">  	"plugins": []</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>presets</p>
<ul>
<li>babel-preset-es2015</li>
<li>babel-preset-react</li>
<li>babel-preset-stage-x(x=0,1,2,3)</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"presets"</span>: [</div><div class="line">    <span class="string">"es2015"</span>,</div><div class="line">    <span class="string">"react"</span>,</div><div class="line">    <span class="string">"stage-2"</span></div><div class="line">  ],</div><div class="line">  <span class="attr">"plugins"</span>: []</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>plugins</p>
<ul>
<li>babel-plugin-transform-es2015-classes</li>
<li>babel-plugin-transform-es2015-arrow-functions</li>
<li>…</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   <span class="attr">"plugins"</span>: [</div><div class="line">     <span class="string">"transform-es2015-classes"</span>,</div><div class="line">     <span class="string">"transform-es2015-arrow-functions"</span></div><div class="line">   ]</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>loose mode</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"plugins"</span>: [</div><div class="line">      //<span class="string">"transform-es2015-classes"</span></div><div class="line">      [<span class="string">"transform-es2015-classes"</span>, &#123; <span class="attr">"loose"</span>: <span class="literal">true</span> &#125;]</div><div class="line">    ]</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI3NTE2NjYxNw==&amp;mid=2650600240&amp;idx=1&amp;sn=88f53bf78b5b174acd6805fe7026cd66&amp;scene=1&amp;srcid=0816pFmqA5bQYhJUHdBBMDuq&amp;key=305bc10ec50ec19bea029543ffd48645f5bec6aeefc9ecf044a7e08d510f51dd27c850d970a291e06e17bcfa70f438e0&amp;ascene=0&amp;uin=MTkxMDY2NDA2MQ%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.11.5+build(15F34" target="_blank" rel="external">扩展—— Babel 6 loose</a>&amp;version=11020201&amp;pass_ticket=eUYpNbnbXM9RBSMCUPMk%2FYHjU3v29WWpWF5gQJ9FeU6LHqIZ0eAx6rz%2FawLCrm9c)</p>
</li>
</ul>
</li>
<li><p>基于环境自定义 Babel</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"presets"</span>: [<span class="string">"es2015"</span>],</div><div class="line">  <span class="attr">"plugins"</span>: [],</div><div class="line">  <span class="attr">"env"</span>: &#123;</div><div class="line">    <span class="attr">"development"</span>: &#123;</div><div class="line">      <span class="attr">"plugins"</span>: [...]</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">"production"</span>: &#123;</div><div class="line">      <span class="attr">"plugins"</span>: [...]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>env</code> : <code>process.env.BABEL_ENV</code> or <code>process.env.NODE_env</code></p>
</li>
</ul>
<h3 id="3-Webpack"><a href="#3-Webpack" class="headerlink" title="3. Webpack"></a>3. Webpack</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//webpack.config.js</span></div><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line">    ···</div><div class="line">    <span class="built_in">module</span>.exports = &#123;</div><div class="line">        ···</div><div class="line">        <span class="built_in">module</span>: &#123;</div><div class="line">            loaders: [</div><div class="line">                &#123;</div><div class="line">                    loader: <span class="string">'babel-loader'</span>,</div><div class="line">                    test: path.resolve(__dirname, <span class="string">'js'</span>),</div><div class="line">                    query: &#123;</div><div class="line">                        presets: [<span class="string">'es2015'</span>],</div><div class="line">                    &#125;,</div><div class="line">                &#125;</div><div class="line">            ]</div><div class="line">        &#125;,</div><div class="line">        ···</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<ul>
<li>tree-shaking</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[swiftype搜索服务更换为Local Serach]]></title>
      <url>http://chriscindy.top/2016/08/10/swiftype%E6%90%9C%E7%B4%A2%E6%9C%8D%E5%8A%A1%E6%9B%B4%E6%8D%A2%E4%B8%BALocal%20Serach/</url>
      <content type="html"><![CDATA[<p>突然发现博客的搜索服务无法使用，查之发现是因为服务提供商 swiftype 目前已经没有了免费账户的选项，15 天试用期结束后如果不付费将无法继续使用。可以选择的账户类型如下：</p>
<p><img src="http://ww4.sinaimg.cn/large/006tKfTcjw1f6onlf2wwxj31kw0qgaf1.jpg" alt="swiftype.jpg"></p>
<p>恕我直言，这是完全不让我们这种小博客用户使用的节奏啊。既然 swiftype 已经无法继续使用，我们只能另寻他路。</p>
<p>Next 的使用文档在 swiftype 之外提供了两种方案：微搜索和 Local Search。</p>
<ul>
<li><p><a href="http://tinysou.com/" target="_blank" rel="external">微搜索</a></p>
<p>国内的一家志在做最好的站内搜索的服务商。截止本文发表时，其官网仍无法注册，进入注册页提示“504 Gateway Time-out”，无奈，放弃。</p>
</li>
</ul>
<ul>
<li><p>Local Search</p>
<p>尝试了一下，还不错，免费，速度堪比 swiftype，Next 定制的外观也还可以，就它了。</p>
<p><img src="http://ww3.sinaimg.cn/large/006tKfTcjw1f6oo7rsw3uj319q116aeu.jpg" alt="localsearch.jpg"></p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Babel 6的loose模式]]></title>
      <url>http://chriscindy.top/2016/08/10/Babel-6%E7%9A%84loose%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006tKfTcjw1f6omyfzq3qj31kw0pu7av.jpg" alt="babel.png"></p>
<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>Babel 的 loose 模式将 ES6 代码转译成 ES5 代码，loose 模式是不太忠实于 ES6 语义的。这篇文章解释了它是怎么工作的以及它的优点与缺点（剧透：通常是不推荐的）。</p>
<p>在这之前，我们先简单了解一下 Babel 中的一些基础知识：</p>
<ul>
<li><p>配置文件</p>
<p>Babel 的配置文件是<code>.babelrc</code>，存放在下项目的根目录下，该文件用来设置预设和插件，基本格式如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"presets"</span>:[],</div><div class="line">  <span class="attr">"plugins"</span>:[]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>presets（预设）</p>
<p>为了将 Babel 的输出配置为符合要求的情况，我们需要指定 Babel 使用什么插件。可以指定的有：</p>
<ul>
<li>单独的插件</li>
<li>预设，即支持各种编译方案的插件集合。</li>
</ul>
<p>下面是一些使用广泛的预设：</p>
<ul>
<li>es2015：将 ES6 代码编译为 ES5</li>
<li>stage-3：将<code>stage 3 ECMAScript proposals</code>编译为ES5</li>
<li>react：将 JSX 编译为 JavaScript 并且移除 Flow 的类型注解</li>
</ul>
<p>预设通过 npm 安装。他们在 npm 中的包名称为其名字加上前缀<code>babel-preset-</code>。比如安装<code>es2015</code>时，我们可以用以下的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install babel-preset-es2015</div></pre></td></tr></table></figure>
</li>
<li><p>plugins（插件）</p>
<p>笼统地讲，插件是在编译过程中应用到输入中的函数。插件有两种重要的类别：</p>
<ul>
<li><p>语法插件。其作用为使 Babel 具备处理内建基础语法之外的语法实体。它们能够帮助构造抽象语法树（AST）。典型的语法插件有：<a href="http://babeljs.io/docs/plugins/syntax-async-functions/" target="_blank" rel="external">syntax-async-functions</a> 以及 <a href="http://babeljs.io/docs/plugins/syntax-jsx/" target="_blank" rel="external">syntax-jsx</a>。</p>
</li>
<li><p>转换插件。其作用为修改抽象语法树。典型的转换插件有：<a href="http://babeljs.io/docs/plugins/transform-async-to-generator/" target="_blank" rel="external">transform-async-to-generator</a>、<a href="http://babeljs.io/docs/plugins/transform-react-jsx/" target="_blank" rel="external">transform-react-jsx</a>、<a href="http://babeljs.io/docs/plugins/transform-es2015-arrow-functions/" target="_blank" rel="external">transform-es2015-arrow-functions</a> 等。</p>
<p>如果你想编译不包含在基础语法之内的代码，那你将同时需要一个语法插件以及与之相对应的转换插件。不过，每个依赖于语法插件的转换插件都将自动触发该语法插件。</p>
<p>插件同样通过 npm 安装，他们在 npm 中的包名称为其名字加上前缀<code>babel-plugin-</code>：</p>
<ul>
<li>安装插件<code>syntax-jsx</code>：<code>npm install babel-plugin-syntax-jsx</code></li>
<li>安装插件<code>transform-react-jsx</code>：<code>npm install babel-plugin-transform-react-jsx</code>​</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>OK，基础知识介绍到这里，如想进一步学习 Babel，可以去到<a href="https://babeljs.io/" target="_blank" rel="external">Babel官网</a>。下面回归主题，探究 Babel 6 的 loose 模式。</p>
<h3 id="2-两种模式"><a href="#2-两种模式" class="headerlink" title="2. 两种模式"></a>2. 两种模式</h3><p>许多 Babel 的插件有两种模式：</p>
<h6 id="•-尽可能符合-ECMAScript6-语义的-normal-模式。"><a href="#•-尽可能符合-ECMAScript6-语义的-normal-模式。" class="headerlink" title="• 尽可能符合 ECMAScript6 语义的 normal 模式。"></a>• 尽可能符合 ECMAScript6 语义的 normal 模式。</h6><h6 id="•-提供更简单-ES5-代码的-loose-模式。"><a href="#•-提供更简单-ES5-代码的-loose-模式。" class="headerlink" title="• 提供更简单 ES5 代码的 loose 模式。"></a>• 提供更简单 ES5 代码的 loose 模式。</h6><p>通常，推荐不使用 loose 模式，使用这种模式的优点和缺点是：</p>
<h6 id="•-优点：生成的代码可能更快，对老的引擎有更好的兼容性，代码通常更简洁，更加的“ES5化”。"><a href="#•-优点：生成的代码可能更快，对老的引擎有更好的兼容性，代码通常更简洁，更加的“ES5化”。" class="headerlink" title="• 优点：生成的代码可能更快，对老的引擎有更好的兼容性，代码通常更简洁，更加的“ES5化”。"></a>• 优点：生成的代码可能更快，对老的引擎有更好的兼容性，代码通常更简洁，更加的“ES5化”。</h6><h6 id="•-缺点：你是在冒险——随后从转译的-ES6-到原生的-ES6-时你会遇到问题。这个险是很不值得冒的。"><a href="#•-缺点：你是在冒险——随后从转译的-ES6-到原生的-ES6-时你会遇到问题。这个险是很不值得冒的。" class="headerlink" title="• 缺点：你是在冒险——随后从转译的 ES6 到原生的 ES6 时你会遇到问题。这个险是很不值得冒的。"></a>• 缺点：你是在冒险——随后从转译的 ES6 到原生的 ES6 时你会遇到问题。这个险是很不值得冒的。</h6><h4 id="2-1-切换到-loose-模式"><a href="#2-1-切换到-loose-模式" class="headerlink" title="2.1 切换到 loose 模式"></a>2.1 切换到 loose 模式</h4><p><a href="https://github.com/bkonkle/babel-preset-es2015-loose" target="_blank" rel="external">es2015-loose</a> 是标准的 ES6 预设（preset）es2015 的 loose 版。<a href="https://github.com/bkonkle/babel-preset-es2015-loose/blob/master/index.js" target="_blank" rel="external">这个预设的代码</a>对什么样的插件有 loose 模式以及怎样开启提供了很好的说明。以下是代码截选：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    plugins: [</div><div class="line">      ···</div><div class="line">      [<span class="built_in">require</span>(<span class="string">"babel-plugin-transform-es2015-classes"</span>), &#123;loose: <span class="literal">true</span>&#125;],</div><div class="line">      <span class="built_in">require</span>(<span class="string">"babel-plugin-transform-es2015-object-super"</span>),</div><div class="line">      ···</div><div class="line">    ]</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这是一个 CommonJS 模块，可以使用任何的 ECMAScript 5，如果你通过<code>.babelrc</code> 或者<code>package.json</code>配置 babel（<a href="http://www.2ality.com/2015/11/configuring-babel6.html" target="_blank" rel="external">详细配置</a>），你需要使用 JSON。也可以包含 preset：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">···</div><div class="line">  "presets": [</div><div class="line">    ···</div><div class="line">    "es2015-loose",</div><div class="line">    ···</div><div class="line">  ],</div><div class="line"> ···</div></pre></td></tr></table></figure></p>
<p>也可以单独引入插件：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">···</div><div class="line"> "plugins": [</div><div class="line">   ···</div><div class="line">   ["transform-es2015-classes", &#123;loose: true&#125;],</div><div class="line">   "transform-es2015-object-super",</div><div class="line">   ···</div><div class="line"> ],</div><div class="line"> ···</div></pre></td></tr></table></figure></p>
<h3 id="3-例子：normal-模式与-loose-模式的输出"><a href="#3-例子：normal-模式与-loose-模式的输出" class="headerlink" title="3. 例子：normal 模式与 loose 模式的输出"></a>3. 例子：normal 模式与 loose 模式的输出</h3><p>让我们看看模式如何影响下面代码的编译：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">        <span class="keyword">this</span>.x = x;</div><div class="line">        <span class="keyword">this</span>.y = y;</div><div class="line">    &#125;</div><div class="line">    toString() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">`(<span class="subst">$&#123;this.x&#125;</span>, <span class="subst">$&#123;this.y&#125;</span>)`</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3-1-normal-模式"><a href="#3-1-normal-模式" class="headerlink" title="3.1 normal 模式"></a>3.1 normal 模式</h4><p>在 normal 模式下，类的 prototype 方法是通过<code>Object.defineProperty</code>添加的（第 A 行），来确保它们是不可以被枚举的，这是 ES6 规范所要求的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> _createClass = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">defineProperties</span>(<span class="params">target, props</span>) </span>&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.length; i++) &#123;</div><div class="line">                <span class="keyword">var</span> descriptor = props[i];</div><div class="line">                descriptor.enumerable = descriptor.enumerable || <span class="literal">false</span>;</div><div class="line">                descriptor.configurable = <span class="literal">true</span>;</div><div class="line">                <span class="keyword">if</span> (<span class="string">"value"</span> <span class="keyword">in</span> descriptor) descriptor.writable = <span class="literal">true</span>;</div><div class="line">                <span class="built_in">Object</span>.defineProperty(target, descriptor.key, descriptor);   <span class="comment">// (A)</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, protoProps, staticProps</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (protoProps) defineProperties(Constructor.prototype, protoProps);</div><div class="line">            <span class="keyword">if</span> (staticProps) defineProperties(Constructor, staticProps);</div><div class="line">            <span class="keyword">return</span> Constructor;</div><div class="line">        &#125;;</div><div class="line">    &#125;)();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot call a class as a function"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> Point = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">            _classCallCheck(<span class="keyword">this</span>, Point);</div><div class="line"></div><div class="line">            <span class="keyword">this</span>.x = x;</div><div class="line">            <span class="keyword">this</span>.y = y;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        _createClass(Point, [&#123;</div><div class="line">            key: <span class="string">"toString"</span>,</div><div class="line">            value: <span class="function"><span class="keyword">function</span> <span class="title">toString</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="string">"("</span> + <span class="keyword">this</span>.x + <span class="string">", "</span> + <span class="keyword">this</span>.y + <span class="string">")"</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;]);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> Point;</div><div class="line">    &#125;)();</div></pre></td></tr></table></figure></p>
<h4 id="3-2-loose-模式"><a href="#3-2-loose-模式" class="headerlink" title="3.2 loose 模式"></a>3.2 loose 模式</h4><p>在 loose 模式下，用通常的赋值方式添加方法（第 B 行），这种风格更像你用 ES5 手动编写代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta"> "use strict"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123; ··· &#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Point = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">        _classCallCheck(<span class="keyword">this</span>, Point);</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.x = x;</div><div class="line">        <span class="keyword">this</span>.y = y;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Point.prototype.toString = <span class="function"><span class="keyword">function</span> <span class="title">toString</span>(<span class="params"></span>) </span>&#123;   <span class="comment">// (B)</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"("</span> + <span class="keyword">this</span>.x + <span class="string">", "</span> + <span class="keyword">this</span>.y + <span class="string">")"</span>;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> Point;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>参考文献：</p>
<blockquote><footer><strong>wd4blue</strong><cite><a href="http://www.w3ctech.com/topic/1708?utm_source=tuicool&utm_medium=referral" target="_blank" rel="external">Babel 6: loose 模式</a></cite></footer></blockquote>
<blockquote><footer><strong>2ality</strong><cite><a href="http://www.2ality.com/2015/11/configuring-babel6.html" target="_blank" rel="external">Configuring Babel 6</a></cite></footer></blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Riot.js特性一览]]></title>
      <url>http://chriscindy.top/2016/07/29/Riot-js%E7%89%B9%E6%80%A7%E4%B8%80%E8%A7%88/</url>
      <content type="html"><![CDATA[<blockquote>
<p>注：本文基于Riot.js v2.5.0版本</p>
</blockquote>
<h2 id="Riot-js简介"><a href="#Riot-js简介" class="headerlink" title="Riot.js简介"></a>Riot.js简介</h2><ul>
<li><p>类似 React 的 <strong>微型</strong> UI 库</p>
</li>
<li><p>自定义标签/虚拟 DOM</p>
</li>
<li><p>适合编写独立组件</p>
</li>
<li><p>MVP 架构</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNbRwjw1f69ltjvz8mj30jg042jrh.jpg" alt="MVP 架构图"></p>
</li>
<li><p>支持 IE9+ ？？</p>
</li>
</ul>
<h2 id="1-自定义标签"><a href="#1-自定义标签" class="headerlink" title="1.自定义标签"></a>1.自定义标签</h2><ol>
<li>布局与逻辑耦合，可重用组件</li>
<li>实际上的语法糖—&gt;编译为 JS</li>
<li><p>虚拟 DOM</p>
<ul>
<li>单向的数据传输： update 或 unmount 都是从 父亲-&gt;孩子</li>
<li>预编译和缓存表达式，解析更加高效</li>
<li>预处理器</li>
<li>可用于服务器端</li>
</ul>
</li>
<li>语法友好<ul>
<li>强大的属性缩写: class={enable: true, hidden: false}</li>
<li>不需要额外的手动绑定，无需记忆 render，state，constructor 等</li>
<li>可插值使用: Add #{items.length + 1} 或 class=”item {selectd: true}”</li>
<li>逻辑代码，可不放在 script 标签内</li>
<li>可使用部分 ES6（完全使用需结合 Babel）</li>
</ul>
</li>
</ol>
<h2 id="2-mixin"><a href="#2-mixin" class="headerlink" title="2.mixin"></a>2.mixin</h2><p>Mixin 可以将公共代码在不同标签之间方便地共享，可以混入 Object 和 new function(){}。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> OptsMixin = &#123;</div><div class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">this</span>.on(<span class="string">'updated'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'Updated!'</span>) &#125;)</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    getOpts: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.opts</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    setOpts: <span class="function"><span class="keyword">function</span>(<span class="params">opts, update</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.opts = opts</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(!update) &#123;</div><div class="line">            <span class="keyword">this</span>.update()</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;my-tag&gt;</div><div class="line">    &lt;h1&gt;&#123; opts.title &#125;&lt;/h1&gt;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.mixin(OptsMixin)</div><div class="line">&lt;<span class="regexp">/my-tag&gt;</span></div></pre></td></tr></table></figure>
<p>声明式 mixin 可在文件之间和项目之间共享 mixin：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">riot.mixin(<span class="string">"defaultData"</span>, &#123;</div><div class="line">    author: <span class="string">"ddfe"</span>,</div><div class="line">    email: <span class="string">"shield@didichuxing.com"</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// in custom tag</span></div><div class="line"><span class="keyword">this</span>.mixin(<span class="string">"defaultData"</span>);</div></pre></td></tr></table></figure>
<h2 id="3-事件"><a href="#3-事件" class="headerlink" title="3.事件"></a>3.事件</h2><ul>
<li><p>自定义标签创建过程：</p>
<ol>
<li>创建标签实例</li>
<li>标签定义中的 JavaScript 被执行</li>
<li>HTML 中的表达式被首次计算并首次触发 “update” 事件</li>
<li>标签被加载 (mount) 到页面上，触发 “mount” 事件</li>
</ol>
</li>
<li><p>监听生命周期事件</p>
<ul>
<li>before-mount </li>
<li>mount</li>
<li>update（改写上下文数据）</li>
<li>updated（操作 DOM）</li>
<li>before-mount</li>
<li>unmount</li>
</ul>
</li>
<li><p>表达式更新方式：</p>
<ol>
<li>当一个事件处理器被调用后自动更新。可以在事件处理器中设置 <code>e.preventUpdate = true</code> 来禁止这种行为。</li>
<li>当前标签实例的 <code>this.update()</code> 方法被调用时</li>
<li>当前标签的任何一个祖先的 <code>this.update()</code> 被调用时. 更新从父亲到儿子单向传播。</li>
<li>当 <code>riot.update()</code> 方法被调用时, 会更新页面上所有的表达式。</li>
</ol>
<p>​</p>
<p>​</p>
</li>
</ul>
<h2 id="4-表达式"><a href="#4-表达式" class="headerlink" title="4.表达式"></a>4.表达式</h2><p>100%纯 JavaScript：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123; title || <span class="string">'Untitled'</span> &#125;</div><div class="line">&#123; results ? <span class="string">'ready'</span> : <span class="string">'loading'</span> &#125;</div><div class="line">&#123; <span class="keyword">new</span> <span class="built_in">Date</span>() &#125;</div><div class="line">&#123; message.length &gt; <span class="number">140</span> &amp;&amp; <span class="string">'Message is too long'</span> &#125;</div><div class="line">&#123; <span class="built_in">Math</span>.round(rating) &#125;</div></pre></td></tr></table></figure>
<p>可放在 html 节点中，也可作为文本节点嵌入：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&#123;</span> /* 属性表达式 */ &#125;&gt;</span></div><div class="line">  &#123; /* 嵌入表达式 */ &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></div></pre></td></tr></table></figure>
<p>注：可通过<code>riot.settings.brackets</code>自定义花括号</p>
<h2 id="5-杂烩"><a href="#5-杂烩" class="headerlink" title="5.杂烩"></a>5.杂烩</h2><ul>
<li><p>嵌套标签</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;account&gt;</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">subscription</span>  <span class="attr">plan</span>=<span class="string">&#123;</span> <span class="attr">opts.plan</span> &#125; <span class="attr">show_details</span>=<span class="string">"true"</span> /&gt;</span></span></div><div class="line"><span class="tag">&lt;/<span class="name">account</span>&gt;</span></div><div class="line"></div><div class="line">&lt;subscription&gt;</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123; opts.plan.name &#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></div><div class="line">  <span class="comment">// 取得标签选项</span></div><div class="line">  <span class="keyword">var</span> plan = opts.plan,</div><div class="line">      show_details = opts.show_details</div><div class="line">  <span class="comment">// 访问父标签实例</span></div><div class="line">  <span class="keyword">var</span> parent = <span class="keyword">this</span>.parent</div><div class="line">&lt;<span class="regexp">/subscription&gt;</span></div></pre></td></tr></table></figure>
<p>父标签的参数通过 <code>riot.mount</code> 方法的参数设置，而子标签的选项通过标签属性来传递。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">riot.mount(<span class="string">'account'</span>, &#123; plan: &#123; name: <span class="string">'ddfe'</span>, age: <span class="string">'4'</span> &#125; &#125;)</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>嵌套HTML</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--definition--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">my-tag</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">yield</span>/&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  this.text = 'world'</div><div class="line"><span class="tag">&lt;/<span class="name">my-tag</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--apply--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">my-tag</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">b</span>&gt;</span>&#123; text &#125;<span class="tag">&lt;/<span class="name">b</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">my-tag</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--result--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">my-tag</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">b</span>&gt;</span>world<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">my-tag</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>带有 <code>name</code> 或 <code>id</code> 属性的 DOM 元素将自动被绑定到上下文中，可直接访问</p>
</li>
<li><p>事件处理器 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;login&gt;</div><div class="line">  &lt;form onsubmit=&#123; submit &#125;&gt;</div><div class="line">  &lt;/form&gt;</div><div class="line"></div><div class="line">  // 上面的表单提交时调用此方法</div><div class="line">  submit(e) &#123;</div><div class="line">  &#125;</div><div class="line">&lt;/login&gt;</div><div class="line"></div><div class="line">//e.currentTarget 事件处理器的所属元素</div><div class="line">//e.target 发起事件的元素</div><div class="line">//e.which 键盘事件中的键值 </div><div class="line">//e.item 循环中的当前元素</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>渲染条件：<code>if = {expression}</code> <code>show</code> <code>hide</code></p>
</li>
<li><p>循环：<code>each = {items}</code>（对象数组）or <code>each = {name, i in items}</code>(非对象数组) or <code>each = {name,value in items}</code>（对象）（不建议使用）</p>
<p>循环中的每一项将建立一个新的上下文，子标签通过 parent 访问父标签定义的方法和属性。</p>
</li>
<li><p>使用标准 HTML 元素作为标签</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;ul riot-tag=<span class="string">"my-tag"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></div><div class="line"></div><div class="line">riot.mount(<span class="string">'my-tag'</span>)</div></pre></td></tr></table></figure>
</li>
<li><p>服务端渲染</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> riot = <span class="built_in">require</span>(<span class="string">'riot'</span>)</div><div class="line"><span class="keyword">var</span> timer = <span class="built_in">require</span>(<span class="string">'timer.tag'</span>)</div><div class="line"></div><div class="line"><span class="keyword">var</span> html = riot.render(timer, &#123; start: <span class="number">42</span> &#125;)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(html) <span class="comment">// &lt;timer&gt;&lt;p&gt;Seconds Elapsed: 42&lt;/p&gt;&lt;/timer&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="6-编译"><a href="#6-编译" class="headerlink" title="6. 编译"></a>6. 编译</h2><p>自定义标签会被编译为 JavaScript</p>
<ul>
<li><p>浏览器内编译</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">"todo.tag"</span> type=<span class="string">"riot/tag"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>预编译：riot 命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">npm install riot -g</div><div class="line"></div><div class="line"># 编译到当前目录</div><div class="line">riot some.tag</div><div class="line"></div><div class="line"># 编译到目标目录</div><div class="line">riot some.tag some_folder</div><div class="line"></div><div class="line"># 编译到目标路径</div><div class="line">riot some.tag some_folder/some.js</div><div class="line"></div><div class="line"># 将源目录下的所有文件编译至目的目录</div><div class="line">riot some/folder path/to/dist</div><div class="line"></div><div class="line"># 将源目录下的所有文件编译（合并）到单个js文件</div><div class="line">riot some/folder all-my-tags.js</div><div class="line"></div><div class="line">参数：</div><div class="line">-w watch 目录 有变化自动编译</div><div class="line">-ext html 指定后缀名</div><div class="line">--config config 使用config.js作配置文件</div><div class="line">--type 指定 js 处理器</div><div class="line">--template 指定 HTML 模板</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>预处理器</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"coffee"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<h2 id="7-观察者-Observable（事件触发器）"><a href="#7-观察者-Observable（事件触发器）" class="headerlink" title="7.观察者 Observable（事件触发器）"></a>7.观察者 Observable（事件触发器）</h2><p>Riot 提供 Observable 以便组件间通信，实现模块化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法1，创建一个观察者，返回一个实例，之后该对象便可以触发和监听事件</span></div><div class="line"><span class="keyword">var</span> ddfe = riot.observable(&#123;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//方法2，使 ddfe 成为观察者</span></div><div class="line">riot.observable(ddfe);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 监听事件</span></div><div class="line">ddfe.on(<span class="string">"event1"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data1, data2</span>)</span>&#123;</div><div class="line">    <span class="comment">// 监听event1事件</span></div><div class="line">    <span class="comment">// data1 和 data2 是trigger传入的参数</span></div><div class="line">    <span class="comment">// data1 = 1, data2 = 2</span></div><div class="line">    <span class="built_in">console</span>.log(data1, data2);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 发布一个事件</span></div><div class="line"><span class="comment">// 该事件带有 1 和 2 作为参数</span></div><div class="line"><span class="comment">// 上面的on("event1")的回调fn将会执行</span></div><div class="line">ddfe.trigger(<span class="string">"event1"</span>, <span class="number">1</span>, <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="comment">// 解除 event1 的所有监听，第二个参数可选</span></div><div class="line"><span class="comment">// 如果有第二个参数 [function]，则只解绑该函数</span></div><div class="line">ddfe.off(<span class="string">"event1"</span>);</div><div class="line"></div><div class="line"><span class="comment">// one 与 on 类似，只是 one 如果执行过一次，就自动解除绑定</span></div><div class="line">ddfe.one(<span class="string">"event1"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data1</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data1);</div><div class="line">&#125;);</div><div class="line">ddfe.trigger(<span class="string">"event1"</span>, <span class="number">1</span>, <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="comment">//删除所有事件的所有监听器</span></div><div class="line">ddfe.off(<span class="string">'*'</span>)</div><div class="line"></div><div class="line"><span class="comment">//对所有的事件删除指定的回调函数</span></div><div class="line">ddfe.off(<span class="string">'*'</span>,fn)</div></pre></td></tr></table></figure>
<h2 id="8-路由"><a href="#8-路由" class="headerlink" title="8.路由"></a>8.路由</h2><p>一个最小化的路由器实现</p>
<p>功能：</p>
<ol>
<li>修改 URL 的 hash 部分</li>
<li>hash 变化时进行通知</li>
<li>查看当前 hash</li>
</ol>
<p>API：</p>
<ol>
<li><p><code>riot.route(callback)</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">riot.route(<span class="function"><span class="keyword">function</span>(<span class="params">collection, id, action</span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//如果 url 变为 customers/987987/edit,则</span></div><div class="line"></div><div class="line"><span class="comment">//collection = 'customers'</span></div><div class="line"></div><div class="line"><span class="comment">//id = '987987'</span></div><div class="line"></div><div class="line"><span class="comment">//action = 'edit'</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>riot.route(filter, callback)</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 精确匹配 `/fruit`</span></div><div class="line">riot.route(<span class="string">'/fruit'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'The list of fruits'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 如果 url 变成 `/blog/2015-09/01`,</span></div><div class="line"><span class="comment">// 回调的参数将被捕捉成 '2015', '09' 和 '01'</span></div><div class="line">riot.route(<span class="string">'/blog/*-*/*'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">year, month, date</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'The page of '</span> + year + <span class="string">'-'</span> + month + <span class="string">'-'</span> date)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p><code>riot.route.create()</code></p>
<p>返回一个新的路由上下文</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">first-tag</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>First tag<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> subRoute = riot.route.create() <span class="comment">// 创建新的路由上下文</span></div><div class="line">    subRoute(<span class="string">'/fruit/*'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">      <span class="comment">/* 公用的部分 */</span></div><div class="line">    &#125;)</div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">first-tag</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">second-tag</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Second tag<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> subRoute = riot.route.create() <span class="comment">// 创建新的路由上下文</span></div><div class="line">    subRoute(<span class="string">'/fruit/apple'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">      <span class="comment">/* 个别的部分 */</span></div><div class="line">    &#125;)</div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">second-tag</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>riot.route(to[, title, shouldReplace])</code></p>
<p> 在内部实现中，</p>
<ul>
<li>如果没有 <code>shouldReplace</code>, 将使用 <code>history.pushState()</code>.</li>
<li>如果有 <code>shouldReplace</code>, 将使用<code>history.replaceState()</code>.</li>
</ul>
</li>
<li><p><code>riot.route.start()</code></p>
<p>开始监听路由变化，需要手动调用</p>
</li>
<li><p><code>riot.route.start(autoExec)</code></p>
<p>riot.route.start(true) &lt;=&gt; riot.route.start()+riot.route.exec()</p>
</li>
<li><p><code>riot.route.stop()</code></p>
</li>
<li><p><code>riot.route.query()</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果 url 变成 `/search?keyword=Apple&amp;limit=30` 将会匹配</span></div><div class="line">riot.route(<span class="string">'/search..'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> q = riot.route.query()</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Search keyword: '</span> + q.keyword)</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Search limit: '</span> + q.limit)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p><code>riot.route.base(base)</code>修改基础路径</p>
</li>
<li><p><code>riot.route.parser(parser[, secondParser])</code></p>
</li>
<li><p>其他，路由优先级等</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">riot.route(<span class="string">'/fruit/apple'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* */</span> &#125;) <span class="comment">// 路由-B (1)</span></div><div class="line">riot.route(<span class="string">'/fruit/orange'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* */</span> &#125;) <span class="comment">// 路由-C (2)</span></div><div class="line">riot.route(<span class="string">'/fruit/*'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123; <span class="comment">/* */</span> &#125;) <span class="comment">// 路由-A (3)</span></div><div class="line"></div><div class="line">riot.route(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* */</span> &#125;) <span class="comment">// 路由-X (3)</span></div><div class="line">riot.route(<span class="string">'/fruit/*'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* */</span> &#125;) <span class="comment">// 路由-Y (1)</span></div><div class="line">riot.route(<span class="string">'/sweet/*'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* */</span> &#125;) <span class="comment">// 路由-Z (2)</span></div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[跨域请求时多出现一条OPTIONS请求的原因及解决办法]]></title>
      <url>http://chriscindy.top/2016/07/20/%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E6%97%B6%E5%A4%9A%E5%87%BA%E7%8E%B0%E4%B8%80%E6%9D%A1options%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>最近在公司项目中与后端联调时遇到了一个很奇怪的问题，前端发出的 DELETE 方法的 Ajax 请求传到服务端就变成了 OPTIONS 请求。由于服务端没有针对 OPTIONS 请求作回应，此时返回的 http 状态码为 405，意为“方法不被允许”（Method not allowed），DELETE 请求自然也是失败。上网查了一番，原理是触发了 W3C 规定的跨域请求时的安全机制。</p>
<p>W3C 规范中的定义如下：</p>
<blockquote>
<p>To protect resources against cross-origin requests that could not originate from certain user agents before this specification existed a preflight request is made to ensure that the resource is aware of this specification. The result of this request is stored in a preflight result cache.</p>
</blockquote>
<p>大意就是出于安全考虑，保护资源不接受来自特定客户端的跨域请求，存在预请求来提前通知资源。而具体做法呢？看下面：</p>
<blockquote>
<p>It gets slightly more complicated if the resource author wants to be able to handle cross-origin requests using methods other than simple methods. In that case the author needs to reply to a preflight request that uses the OPTIONS method and then needs to handle the actual request that uses the desired method (DELETE in this example) and give an appropriate response.<br>服务端想要处理使用简单方法之外的方法进行的跨域请求时，需要对使用OPTIONS方法的预请求进行响应，然后才能处理实际请求。</p>
</blockquote>
<p>所谓简单方法，是指：</p>
<ul>
<li>只使用 GET, HEAD 或者 POST 请求方法。如果使用 POST 向服务器端传送数据，则数据类型(Content-Type)只能是 application/x-www-form-urlencoded, multipart/form-data 或 text/plain中的一种。</li>
<li>不会使用自定义请求头（类似于 X-Modified 这种）。</li>
</ul>
<p>OPTIONS 是 HTTP/1.1 里的方法，用来获取更多服务器端的信息，是一个不应该对服务器数据造成影响的方法。通过这个方法，客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能。</p>
<p>到这里，我们对整个情况就很明了了：当 Ajax 跨域请求时，如果 HTTP 方法是非简单方法，则客户端即浏览器会发出 OPTIONS 方法的预请求去询问服务端，在得到允许性质的回应后，才会发送真正的请求；如果服务端对预请求拒绝，则真正的 DELETE 请求等不会发出。</p>
<p>看到这里，相信各位也知道如何解决该问题了：服务端对 OPTIONS 预请求给出允许回应。不过，需要注意的是，不应该满足所有的 OPTIONS 请求，否则这一安全措施便形同虚设了。最好是建立一套验证机制，对符合条件的客户端请求给出允许回应。至于如何实现，就靠我们的后端小伙伴啦。有兴趣的朋友可以查看 MDN 上的这篇文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="external">HTTP访问控制(CORS)</a></p>
<p>其他参考文献：</p>
<ul>
<li><a href="http://www.w3.org/TR/cors/" target="_blank" rel="external">W3C Cross-Origin Resource Sharing</a></li>
<li><a href="http://www.tangshuang.net/2271.html" target="_blank" rel="external">jquery ajax 请求中多出现一次 OPTIONS 请求及其解决办法</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[译]使用Riot，ES6和Webpack构建应用]]></title>
      <url>http://chriscindy.top/2016/07/11/%E8%AF%91-%E4%BD%BF%E7%94%A8Riot%EF%BC%8CES6%E5%92%8CWebpack%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>在读完 Muut 上 <a href="https://muut.com/blog/technology/frameworkless-javascript.html" target="_blank" rel="external">Frameworkless JavaScript</a> 这篇博文后，我遇上了 <a href="http://riotjs.com/zh/" target="_blank" rel="external">Riot</a>，请一定先阅读该博文！Muut 的程序员拿出实际行动编写了 <a href="http://riotjs.com/zh/" target="_blank" rel="external">Riot</a>，一个 <a href="https://muut.com/blog/technology/riot-2.0/" target="_blank" rel="external">类似React</a> 的用来构建响应式UI组件的微型库。</p>
<p>阅读Riot的文档时，令我感触最深的是 Riot 竟如此容易理解——相比 React 来说，在 Riot 里需要学习的术语和概念极少（说实话，和 Polymer 和 Angular 等比起来，Riot 也是十分简单易懂的）。</p>
<p>为了有助于学习 Riot，我把自己用 React 编写的 <a href="https://github.com/srackham/flux-backbone-todo" target="_blank" rel="external">flux-backbone-todo</a> 搬运到了用 Riot 编写的 <a href="https://github.com/srackham/riot-todo" target="_blank" rel="external">Riot Todo app</a> 上。这篇博文就是我记录这次重构经历的笔记的合集。</p>
<p>如果觉得文章太长，这里是精简版：</p>
<ol>
<li><p>Riot 确实践行了它最小化的座右铭。Todo 应用的 Riot 版本（未压缩）只有很小的 32 KB。作为对比，React 版本则达到了 964 KB 之多（即使减去在 Riot 版本中未使用到的 Backbone 和 jQuery，React 版本仍然有 600 KB）。不管你怎么看，这都是一个巨大的差异。</p>
</li>
<li><p>Riot 有那种很少见的“刚刚好”的感觉，使用起来非常愉悦。</p>
</li>
<li>Riot 是一个相对较新的方案，因此我没有找到其在大一些的项目中的性能方面的统计数据。在大型项目中 Riot 表现究竟怎样尚未有定论，我希望它能够做的很好。</li>
</ol>
<p>如果你对 Riot 还不熟悉，可以先去浏览一下 <a href="http://riotjs.com/zh/" target="_blank" rel="external">Riot官网</a>——开发文档是第一课。我将列出一些我所学到的但是阅读文档时不一定很明显易懂的内容，而不会去讨论 Riot 是如何工作的。</p>
<h2 id="在-Riot-中使用-ES6"><a href="#在-Riot-中使用-ES6" class="headerlink" title="在 Riot 中使用 ES6"></a>在 Riot 中使用 ES6</h2><p><a href="https://github.com/srackham/riot-todo" target="_blank" rel="external">示例的应用</a>采用 ES6 编写，我使用 <a href="http://6to5.org" target="_blank" rel="external">6to5</a> 转译器将其转换为 ES5 代码，使用 <a href="http://webpack.github.io" target="_blank" rel="external">Webpack</a> 将编译后的代码以及需要的库一起打包。这种方式使得联结 JavaScript 模块成为必要——当你理解最新的 ES6 中 <code>import</code> 和 <code>export</code> 表述的优势时（看这个<a href="https://github.com/srackham/riot-todo/blob/master/src/index.js" target="_blank" rel="external">示例</a>），你就会知道使用 ES6 编写代码是非常棒的。</p>
<p>Webpack通过<a href="https://github.com/srackham/riot-todo/blob/master/webpack.config.js" target="_blank" rel="external">配置</a>可以使用 <code>6to5 loader</code> 将 ES6 源码自动转换成 CommonJS 格式的 ES5 模块，再将其打包至一个单独的 <code>bundle.js</code> 文件。</p>
<h2 id="为什么我不使用-Riot-的-tag-文件"><a href="#为什么我不使用-Riot-的-tag-文件" class="headerlink" title="为什么我不使用 Riot 的 .tag 文件"></a>为什么我不使用 Riot 的 <code>.tag</code> 文件</h2><p>Riot 标签文件是指包含 HTML 标记以及 JavaScript UI 逻辑的 HTML 模板。如果你已经浏览过了上面提到的 <a href="https://github.com/srackham/riot-todo" target="_blank" rel="external">Todo应用</a>，你可能会疑惑标签文件在哪里——答案是我已经不再使用它们，并且更喜欢用 JavaScript 来替代之。去除 <code>.tag</code> 文件简化了我的编码、加工和工作流程。对我来说，标签文件的复杂性和局限性大于它任何可以感知到的优点。</p>
<p>这并不是对 Riot 的一种批判。对标签文件来说，灵活的地方在于它完全可选而非强制使用，在此记录我不使用它的原因。</p>
<p>当你审视编译后的 JavaScript 代码时，你会看到 Riot 标签文件其实是一层轻微的语法糖.</p>
<ul>
<li>它添加了额外的概念层——新的或者比较新的语法和语义需要学习。</li>
<li>它添加了额外的编译步骤。</li>
<li>标签文件编译器指定了你可以使用的语言和模板（CoffeeScript、ES6和Jade），这有悖于“使用你最喜欢的工具”的理念。</li>
<li>标签构造主体的逻辑脱离上下文：<ul>
<li>这使得标签文件无法被编辑器/IDE 的代码检测以及其他的工具处理</li>
<li>涉及 <code>this</code> 时，脱离上下文意味着代码不是合法的 JavaScript 并且在编辑器/IDE 中会报错</li>
</ul>
</li>
<li>目前没有对模块化（CommonJS，AMD）标签文件编译为普通 JavaScript 的支持。</li>
<li>标签文件需要构建工具（比如 Webpack 和 Browserify）直接使用标签转换器来进行转换。</li>
<li><p>类似 ES6 的构造方法很棒但它们不是合法的 JavaScript 并且很可能总是成为持续混乱（语法和语义上）的来源。你可以使用 ES6 的<em>箭头函数</em>以几乎相同的简洁程度来获得相同的语义（拥有词法作用域的 <code>this</code>），举例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.add = (e) =&gt; &#123;</div><div class="line">	<span class="keyword">var</span> input = e.target[<span class="number">0</span>]</div><div class="line">	<span class="keyword">this</span>.items.push(input.value)</div><div class="line">	input.value = <span class="string">''</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这里有一个使用 ES6 模板字符串和箭头函数的 ES6 形式的 JavaScript 标签文件的<a href="https://github.com/srackham/riot-todo/blob/0.1.1/src/tags.js" target="_blank" rel="external">例子</a>。</p>
<p>ES6 模板字符串提高了标签 HTML 模板的可读性。相似的，如果你使用的是 CoffeeScript，那么你可以使用 CoffeeScript 块字符串。<a href="http://facebook.github.io/jsx/" target="_blank" rel="external">JSX</a> 是另一种可选项——React 的 JSX 转换器可以经过修改然后生成字符串文本，这样你就可以获得现有的 JSX 工具的支持。</p>
<h2 id="Riot和React的基本区别"><a href="#Riot和React的基本区别" class="headerlink" title="Riot和React的基本区别"></a>Riot和React的基本区别</h2><p>最重要的区别在于 UI 标记模板是如何声明的：</p>
<ul>
<li>在 React 中 UI 标记模板是在你的 JavaScript 源码中生成的（使用 JSX 语言的扩展）。</li>
<li>Riot 则反转了 React 的模型，将标记和逻辑都放在 HTML（标签）文件中。</li>
</ul>
<p>这种反转的结果是 React 模板 DSL（领域特定语言）就是 JavaScript，而 Riot 依赖自定义的模板 DSL（采用自定义标签实现）。下面是两个简化的从一个 todo 事项的数组中生成一个列表的例子，第一个采用 React JavaScript编写，第二个是等价的 Riot 标签标记形式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">  todos.map(todo =&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">TodoItemComponent</span> <span class="attr">todo</span>=<span class="string">&#123;todo&#125;</span> /&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>)</div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">each</span>=<span class="string">"&#123;todo in todos&#125;"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">todo-item</span> <span class="attr">todo</span>=<span class="string">"&#123;todo&#125;"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<p>第一个例子中使用了 JavaScript 的 <code>map</code> 函数来生成一个 <code>&lt;li&gt;</code> 元素的列表；第二个例子则使用了 Riot 自定义的 <code>each</code> 模板属性。</p>
<p>Steve Luscher 在这个<a href="https://www.youtube.com/watch?v=rI0GQc__0SM#t=1325" target="_blank" rel="external">视频</a>的结尾解释了为何他认为 JavaScript 比自定义模板 DSL 更优秀——你不仅需要学习一门自定义的 DSL，而且还要拘泥于这套 DSL 提供的特性的束缚。对于像上面这样较小的普通用例来说，两种方式其实没太多选择余地，但是在编写更大的高度动态化的 UI 组件时，React 的 JavaScript 方式的威力和灵活性就明显更优越了。</p>
<h2 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h2><h3 id="避免自关闭的XHTML风格的标签"><a href="#避免自关闭的XHTML风格的标签" class="headerlink" title="避免自关闭的XHTML风格的标签"></a>避免自关闭的XHTML风格的标签</h3><p>不要用<code>/&gt;</code>来关闭标签，因为它不总是立刻就能关闭标签。当以 HTML5 元素对待时，<code>&lt;foo /&gt;</code> 表示<code>&lt;foo&gt;</code>（然而在 XHTML 中<code>&lt;foo /&gt;</code>表示<code>&lt;foo&gt;&lt;/foo&gt;</code>），换言之，HTML5 会忽略<code>/</code>字符。有关这个话题可以在 <a href="http://stackoverflow.com/questions/9845011/are-custom-elements-valid-html5/9845124#9845124" target="_blank" rel="external">Stackoverflow</a> 上查看更多讨论。还可以查看下面两处内容：</p>
<ul>
<li><a href="http://riotjs.com/forum/#!/using:closing-html5-tags-with-" target="_blank" rel="external">使用<code>/&gt;</code>关闭HTML5标签可能造成无法预料的结果</a></li>
<li><a href="http://riotjs.com/forum/#!/using:misplaced-form-end-tag" target="_blank" rel="external">放错位置的表单结束标签</a></li>
</ul>
<h3 id="绑定标签事件处理器到-this-上"><a href="#绑定标签事件处理器到-this-上" class="headerlink" title="绑定标签事件处理器到 this 上"></a>绑定标签事件处理器到 this 上</h3><p>绑定标签事件处理器到 this 上，以确保这些处理器总是和标签文本一起清除（可选的方式是使用约定俗成的<code>var self = this</code>）。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  dispatcher.trigger(dispatcher.CLEAR_TODOS);</div><div class="line">&#125;.bind(<span class="keyword">this</span>);</div></pre></td></tr></table></figure>
<p>使用 ES6 中的词法作用域绑定的箭头函数也可以获得相同的效果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.clear = (e) =&gt; &#123;</div><div class="line">  dispatcher.trigger(dispatcher.CLEAR_TODOS);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="关于循环项"><a href="#关于循环项" class="headerlink" title="关于循环项"></a>关于循环项</h3><p>使用<code>each={item in items}</code>结构将当前的循环项目传递给自定义的子标签。在下面的例子中，自定义的<code>todo-item</code>标签内的代码可以使用<code>opts.todo</code>来获取当前的 todo 项：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">each</span>=<span class="string">"&#123;todo in opts.store.todos&#125;"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">todo-item</span> <span class="attr">store</span>=<span class="string">"&#123;parent.opts.store&#125;"</span> <span class="attr">todo</span>=<span class="string">"&#123;todo&#125;"</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="命名空间事件名称"><a href="#命名空间事件名称" class="headerlink" title="命名空间事件名称"></a>命名空间事件名称</h3><p>使用命名空间加冒号的约定来组织应用的事件名称，比如<code>admin:edit</code>，<code>admin:delete</code>，<code>admin:new</code>等。</p>
<h3 id="可以在-CSS-文件中使用自定义标签"><a href="#可以在-CSS-文件中使用自定义标签" class="headerlink" title="可以在 CSS 文件中使用自定义标签"></a>可以在 CSS 文件中使用自定义标签</h3><p>自定义标签最终会被渲染生成到 DOM 中，因此它们可以使用在 CSS 选择器和 DOM 审查中使用，这里是一个<a href="https://github.com/srackham/riot-todo/blob/master/dist/index.css" target="_blank" rel="external">例子</a>。</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>当用 Webpack 打包时你需要使用<a href="https://github.com/srackham/riot-todo/blob/master/webpack.config.js" target="_blank" rel="external">开发工具 source-map 配置选项</a>来为你打包后的应用生成 <a href="http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/" target="_blank" rel="external">source map</a> 文件。这使得你可以在 ES6 的源码文件中进行调试。</p>
<p>当需要浏览和调试源码时，打开浏览器的 <em>Sources 窗口</em>然后定位到<code>webpack:///.</code>文件夹：</p>
<ul>
<li>在 Firefox 中：打开 Debugger（Ctrl+Shift+S）。</li>
<li>在 Google Chrome 中：打开 Console（Ctrl+Shift+J）然后点击 <em>Sources</em> 标签来查看源码面板。</li>
</ul>
<p>我不是很喜欢调试程序和设置断点——大多数情况下我仅仅会有策略地在代码中放置暂时性的<code>console.log()</code>。</p>
<h2 id="未来蓝图"><a href="#未来蓝图" class="headerlink" title="未来蓝图"></a>未来蓝图</h2><p>Riot（类似 React）是一个 UI 库而不是一个框架。这非常棒（相对于大包大揽的框架来说，我更喜欢小而精的库的集合），但是对于具有一定复杂度的应用来说就需要条理清晰的高级的结构（一个体系结构）来提高可伸缩性、可发展性和可维护性。<a href="https://www.npmjs.com/package/flux" target="_blank" rel="external">Flux</a> 为类似React的应用增加了体系结构的选择。我喜欢 Flux，因为它很容易理解并且它能给人一种很直观的感觉（并非出于任何理论上的信仰）。<a href="https://github.com/srackham/riot-todo" target="_blank" rel="external">Riot Todo app</a> 使用了名为 <a href="https://github.com/jimsparkman/RiotControl" target="_blank" rel="external">RiotControl</a> 的 Flux 风格的 dispatcher（经过轻微修改）来实现 Flux 体系结构。</p>
<blockquote><p>原文出处：</p>
<footer><strong>srackham</strong><cite><a href="http://blog.srackham.com/posts/riot-es6-webpack-apps/" target="_blank" rel="external">Building Apps with Riot, ES6 and Webpack</a></cite></footer></blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Composition Event]]></title>
      <url>http://chriscindy.top/2016/07/11/Composition-Event/</url>
      <content type="html"><![CDATA[<p>Composition Event，中文译为复合事件，是 DOM 3 级事件中新添加的一类事件类型，用于处理 IME 的输入序列。IME（Input Method Editor，输入法编辑器）可以让用户输入在物理键盘上找不到的字符。复合事件就是针对检测和处理这种输入而设计的。也因为以上所述原因，复合事件很少为通常使用拉丁系语言输入的开发者所知（因为拉丁字母都能通过物理键盘输入）。当然，即使是使用非拉丁系语言比如中文作为输入的开发者，也不见得知道复合事件，因为开发中用到该种事件类型的情况比较少见。</p>
<p>IME 复合系统的工作原理如下：缓存用户的键盘输入，直到一个字符被选中后才确定输入。缓存的键盘输入会暂时展示在输入框中，但不会真正被插入到 DOM 中。如下图所示。但是如果在复合事件的过程中改变了输入框的值（比如切换了输入法或者直接按下 enter 键），复合事件将提前结束，同时缓存的键盘输入值将会插入到输入框中。</p>
<p><img src="http://ww3.sinaimg.cn/large/72f96cbagw1f5pr65nfcxj20zi09cwfq.jpg" alt="10:21:17.jpg"></p>
<p>复合事件类型包含以下几种事件：</p>
<ul>
<li>compositionstart：当 IME 的文本复合系统打开时触发。</li>
<li>compositionend：在 IME 的文本复合系统关闭即用户选中了字符并确定输入时触发，表示返回正常键盘的输入状态。<br>-compositionupdate：在 compositionstart 事件触发后，compositionend 事件触发前这段时间内，每次向输入字段中进行输入时均会触发。</li>
</ul>
<p>注：input 事件将在复合事件后触发。</p>
<p>但是，实际情况与理想还是有一定距离的，复合事件的兼容性比较一般。下图是 MDN 中列出的兼容性表现，详情可见 <a href="https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent" target="_blank" rel="external">MDN</a>:</p>
<p><img src="http://ww1.sinaimg.cn/large/72f96cbagw1f5pr91ls0nj21420dg75t.jpg" alt="10:24:08.jpg"></p>
<p><img src="http://ww1.sinaimg.cn/large/72f96cbagw1f5pr973kpuj214s0dtabp.jpg" alt="10:24:13.jpg"></p>
<p>综上，在使用复合事件处理 input 相关的问题时，仍然需要慎重。</p>
<p>注：本文参考尤雨溪博客中 <a href="http://blog.evanyou.me/2014/01/03/composition-event/" target="_blank" rel="external">DOM COMPOSITION EVENTS COMPATIBILITY NOTES</a> 一文。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[两个Git帐号如何在一台电脑上共存]]></title>
      <url>http://chriscindy.top/2016/07/08/%E4%B8%A4%E4%B8%AAGit%E5%B8%90%E5%8F%B7%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%8A%E5%85%B1%E5%AD%98/</url>
      <content type="html"><![CDATA[<p>相信很多开发者都会遇到在自己的电脑上使用不止一个 git 帐号的情况。一个一般是自己的 github 帐号，另一个则是公司的 git 帐号，比如 gitlab、bitbucket 等。如果采用 https 方式通信，那么 git 帐号间不会有冲突，但你在每次 pull、push 的时候都要输入帐号密码，十分繁琐。而且当代码库达到十分庞大的规模时，如果仍然采用 https 方式，在 git pull 时可能出现超时不响应的情况，此时只能采用 ssh 方式。ssh 在配置完 ssh key 后使用起来很方便，但是 git 帐号间可能出现冲突，这时候该如何解决呢？<br>配置 ssh key 的方式此处不再赘述，假设 <code>.ssh</code> 文件夹下有 id_rsa、id_rsa.pub、didi_id_rsa、didi_id_rsa.pub，分别对应个人 github 帐号私钥公钥以及公司 git 帐号私钥公钥。如果不进行设置，使用 github 账号时没有问题，但是使用公司账号时，由于默认情况下私钥存放在 <code>id_rsa</code> 文件中，因此 git 仍会尝试用 id_rsa 中而不是 didi_id_rsa 中的私钥去与服务器上添加的公钥进行比对，自然而然会报错。通常这种情况下 git 会让你输入密码，笔者连续三次输入密码错误（其实根本不知道该密码为何物），报错，Permission denied。<br>网络上的解决方案普遍为在 ssh 的配置文件中加入以下字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Host github.com</div><div class="line"> hostname gitlab.zjut.com</div><div class="line"> User Boy-A</div><div class="line"> IdentityFile /User/&lt;yourusername&gt;/.ssh/id_rsa</div><div class="line"> </div><div class="line">Host git.xiaojukeji.com</div><div class="line"> hostname git.xiaojukeji.com</div><div class="line"> User Boy-B</div><div class="line"> IdentityFile /User/&lt;yourusername&gt;/.ssh/didi_id_rsa</div></pre></td></tr></table></figure>
<p>该文件的主要作用就是指明各个 git 帐号对应的 User 以及 IdentityFile 的文件位置。当配置完毕后，在各个项目 repo 中应用自己的用户名以及邮箱：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1.取消 global</div><div class="line">git config --global --unset user.name</div><div class="line">git config --global --unset user.email</div><div class="line"></div><div class="line">2.设置每个项目 repo 的自己的 user.email</div><div class="line">git config  user.email &quot;xxxx@xx.com&quot;</div><div class="line">git config  user.name &quot;ddfe&quot;</div></pre></td></tr></table></figure>
<p>如此，各个 git 帐号间就可以“井水不犯河水”了。</p>
<p>但是，最麻烦的地方其实并不在这里，而是这个配置文件究竟位于何处。根据网友的分享，Window 系统中，该配置信息存放在名为 config 的文件中，位置在 <code>~/.ssh/</code> 目录下，而在Linux/Unix系统中配置信息则保存在 ssh_config 文件中，至于位置，众说纷纭。笔者使用的是 macOS 系统，尝试用 “ssh -vT git@git.xiaojukeji.com” 去查看 ssh 连接主机的 debug 信息，终于发现了头绪，debug信息的第二行如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">debug1: Reading configuration data /etc/ssh/ssh_config</div></pre></td></tr></table></figure>
<p>终于找到了文件的位置！修改之，大功告成！</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ol>
<li>使用命令 “ssh -vT git@xxx.com” 查看 ssh_config 文件的位置</li>
<li>进入 ssh_config 文件，配置各个 git 帐号的 User 以及 IdentityFIle</li>
<li>在各个项目中配置好 user.name 以及 user.email</li>
<li>在各个 git 帐号间尽情穿梭吧~</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://chriscindy.top/2016/07/08/Hello%20World/</url>
      <content type="html"><![CDATA[<p>恩，这是 hexo 建好后默认的第一篇博文，没有想过删除它，因为我觉得对于这样一个有纪念意义的时刻，应该有一篇文章能够记录一下。</p>
<p>没错，终于有自己可以写文章的地方了，感觉就像是终于有了一个只属于自己的小窝，这种美妙的感觉难以言表。从今以后，就在这里分享技术，感悟生活啦。</p>
<p>配置 Hexo 的过程并不困难，就是有些繁琐。之前选用了一个比较小众但很清新的主题 <a href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="external">even</a>，但是发现有各种功能上的缺失，终于还是决定回到最强势最完善的 NexT 上，折腾一圈，安装完各种插件，看着博客的功能慢慢丰满起来，虽然没有太大的难度，但是仍有一种满满的成就感。</p>
<p>所以，Hello World，向成为前端大拿努力！</p>
]]></content>
    </entry>
    
  
  
</search>
