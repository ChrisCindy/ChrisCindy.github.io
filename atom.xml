<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sunflower-&gt;FE</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chriscindy.top/"/>
  <updated>2016-07-11T03:26:38.000Z</updated>
  <id>http://chriscindy.top/</id>
  
  <author>
    <name>ChrisCindy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[转]使用Riot，ES6和Webpack构建应用</title>
    <link href="http://chriscindy.top/2016/07/11/%E8%BD%AC-%E4%BD%BF%E7%94%A8Riot%EF%BC%8CES6%E5%92%8CWebpack%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/"/>
    <id>http://chriscindy.top/2016/07/11/转-使用Riot，ES6和Webpack构建应用/</id>
    <published>2016-07-11T03:10:52.000Z</published>
    <updated>2016-07-11T03:26:38.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;&lt;p&gt;原文出处：&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;srackham&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;http://blog.srackham.com/posts/riot-es6-webpack-apps/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Building Apps with Riot, ES6 and Webpack&lt;/a&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;p&gt;在读完Muut上&lt;a href=&quot;https://muut.com/blog/technology/frameworkless-javascript.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Frameworkless JavaScript&lt;/a&gt;这篇博文后，我遇上了&lt;a href=&quot;http://riotjs.com/zh/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Riot&lt;/a&gt;，请一定先阅读该博文！Muut的程序员拿出实际行动编写了&lt;a href=&quot;http://riotjs.com/zh/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Riot&lt;/a&gt;，一个&lt;a href=&quot;https://muut.com/blog/technology/riot-2.0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;类似React&lt;/a&gt;的用来构建响应式UI组件的微型库。&lt;/p&gt;
&lt;p&gt;阅读Riot的文档时，令我感触最深的是Riot竟如此容易理解——相比React来说，在Riot里需要学习的术语和概念极少（说实话，和Polymer和Angular等比起来，Riot也是十分简单易懂的）。&lt;/p&gt;
&lt;p&gt;为了有助于学习Riot，我把自己用React编写的&lt;a href=&quot;https://github.com/srackham/flux-backbone-todo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;flux-backbone-todo&lt;/a&gt;搬运到了用Riot编写的&lt;a href=&quot;https://github.com/srackham/riot-todo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Riot Todo app&lt;/a&gt;上。这篇博文就是我记录这次重构经历的笔记的合集。&lt;/p&gt;
&lt;p&gt;如果觉得文章太长，这里是精简版：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Riot确实践行了它最小化的座右铭。Todo应用的Riot版本（未压缩）只有很小的32KB。作为对比，React版本则达到了964KB之多（即使减去在Riot版本中未使用到的Backbone和jQuery，React版本仍然有600KB）。不管你怎么看，这都是一个巨大的差异。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Riot有那种很少见的“刚刚好”的感觉，使用起来非常愉悦。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Riot是一个相对较新的方案，因此我没有找到其在大一些的项目中的性能方面的统计数据。在大型项目中Riot表现究竟怎样尚未有定论，我希望它能够做的很好。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果你对Riot还不熟悉，可以先去浏览一下&lt;a href=&quot;http://riotjs.com/zh/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Riot官网&lt;/a&gt;——开发文档是第一课。我将列出一些我所学到的但是阅读文档时不一定很明显易懂的内容，而不会去讨论Riot是如何工作的。&lt;/p&gt;
&lt;h2 id=&quot;在Riot中使用ES6&quot;&gt;&lt;a href=&quot;#在Riot中使用ES6&quot; class=&quot;headerlink&quot; title=&quot;在Riot中使用ES6&quot;&gt;&lt;/a&gt;在Riot中使用ES6&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/srackham/riot-todo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;示例的应用&lt;/a&gt;采用ES6编写，我使用&lt;a href=&quot;http://6to5.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;6to5&lt;/a&gt;转译器将其转换为ES5代码，使用&lt;a href=&quot;http://webpack.github.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Webpack&lt;/a&gt;将编译后的代码以及需要的库一起打包。这种方式使得联结JavaScript模块成为必要——当你理解最新的ES6中&lt;code&gt;import&lt;/code&gt;和&lt;code&gt;export&lt;/code&gt;表述的优势时（看这个&lt;a href=&quot;https://github.com/srackham/riot-todo/blob/master/src/index.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;示例&lt;/a&gt;），你就会知道使用ES6编写代码是非常棒的。&lt;/p&gt;
&lt;p&gt;Webpack通过&lt;a href=&quot;https://github.com/srackham/riot-todo/blob/master/webpack.config.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;配置&lt;/a&gt;可以使用&lt;code&gt;6to5 loader&lt;/code&gt;将ES6源码自动转换成CommonJS格式的ES5模块，再将其打包至一个单独的&lt;code&gt;bundle.js&lt;/code&gt;文件。&lt;/p&gt;
&lt;h2 id=&quot;为什么我不使用Riot的-tag文件&quot;&gt;&lt;a href=&quot;#为什么我不使用Riot的-tag文件&quot; class=&quot;headerlink&quot; title=&quot;为什么我不使用Riot的.tag文件&quot;&gt;&lt;/a&gt;为什么我不使用Riot的.tag文件&lt;/h2&gt;&lt;p&gt;Riot标签文件是指包含HTML标记以及JavaScript UI逻辑的HTML模板。如果你已经浏览过了上面提到的&lt;a href=&quot;https://github.com/srackham/riot-todo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Todo应用&lt;/a&gt;，你可能会疑惑标签文件在哪里——答案是我已经不再使用它们，并且更喜欢用JavaScript来替代之。去除&lt;code&gt;.tag&lt;/code&gt;文件简化了我的编码、加工和工作流程。对我来说，标签文件的复杂性和局限性大于它任何可以感知到的优点。&lt;/p&gt;
&lt;p&gt;这并不是对Riot的一种批判。对标签文件来说，灵活的地方在于它完全可选而非强制使用，在此记录我不使用它的原因。&lt;/p&gt;
&lt;p&gt;当你审视编译后的JavaScript代码时，你会看到Riot标签文件其实是一层轻微的语法糖.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它添加了额外的概念层——新的或者比较新的语法和语义需要学习。&lt;/li&gt;
&lt;li&gt;它添加了额外的编译步骤。&lt;/li&gt;
&lt;li&gt;标签文件编译器指定了你可以使用的语言和模板（CoffeeScript、ES6和Jade），这有悖于“使用你最喜欢的工具”的理念。&lt;/li&gt;
&lt;li&gt;标签构造主体的逻辑脱离上下文：&lt;ul&gt;
&lt;li&gt;这使得标签文件无法被编辑器/IDE的代码检测以及其他的工具处理&lt;/li&gt;
&lt;li&gt;涉及&lt;code&gt;this&lt;/code&gt;时，脱离上下文意味着代码不是合法的JavaScript并且在编辑器/IDE中会报错&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;目前没有对模块化（CommonJS，AMD）标签文件编译为普通JavaScript的支持。&lt;/li&gt;
&lt;li&gt;标签文件需要构建工具（比如Webpack和Browserify）直接使用标签转换器来进行转换。&lt;/li&gt;
&lt;li&gt;类似ES6的构造方法很棒但它们不是合法的JavaScript并且很可能总是成为持续混乱（语法和语义上）的来源。你可以使用ES6的&lt;em&gt;箭头函数&lt;/em&gt;以几乎相同的简洁程度来获得相同的语义（拥有词法作用域的&lt;code&gt;this&lt;/code&gt;），举例如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;figcaption&gt;&lt;span&gt;javascript&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;this.add = (e) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  var input = e.target[0]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  this.items.push(input.value)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  input.value = &amp;apos;&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里有一个使用ES6模板字符串和箭头函数的ES6形式的JavaScript标签文件的&lt;a href=&quot;https://github.com/srackham/riot-todo/blob/0.1.1/src/tags.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;例子&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;ES6模板字符串提高了标签HTML模板的可读性。相似的，如果你使用的是CoffeeScript，那么你可以使用CoffeeScript块字符串。&lt;a href=&quot;http://facebook.github.io/jsx/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JSX&lt;/a&gt;是另一种可选项——React的JSX转换器可以经过修改然后生成字符串文本，这样你就可以获得现有的JSX工具的支持。&lt;/p&gt;
&lt;h2 id=&quot;Riot和React的基本区别&quot;&gt;&lt;a href=&quot;#Riot和React的基本区别&quot; class=&quot;headerlink&quot; title=&quot;Riot和React的基本区别&quot;&gt;&lt;/a&gt;Riot和React的基本区别&lt;/h2&gt;&lt;p&gt;最重要的区别在于UI标记模板是如何声明的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在React中UI标记模板是在你的JavaScript源码中生成的（使用JSX语言的扩展）。&lt;/li&gt;
&lt;li&gt;Riot则反转了React的模型，将标记和逻辑都放在HTML（标签）文件中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种反转的结果是React模板DSL（领域特定语言）就是JavaScript，而Riot依赖自定义的模板DSL（采用自定义标签实现）。下面是两个简化的从一个todo事项的数组中生成一个列表的例子，第一个采用React JavaScript编写，第二个是等价的Riot标签标记形式：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;ul&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  todos.map(todo =&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;li&amp;gt;&amp;lt;TodoItemComponent todo=&amp;#123;todo&amp;#125; /&amp;gt;&amp;lt;/li&amp;gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;ul&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;lt;li each=&amp;quot;&amp;#123;todo in todos&amp;#125;&amp;quot;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;todo-item todo=&amp;quot;&amp;#123;todo&amp;#125;&amp;quot;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;lt;/li&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第一个例子中使用了JavaScript的&lt;code&gt;map&lt;/code&gt;函数来生成一个&lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;元素的列表；第二个例子则使用了Riot自定义的&lt;code&gt;each&lt;/code&gt;模板属性。&lt;/p&gt;
&lt;p&gt;Steve Luscher在这个&lt;a href=&quot;https://www.youtube.com/watch?v=rI0GQc__0SM#t=1325&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;视频&lt;/a&gt;的结尾解释了为何他认为JavaScript比自定义模板DSL更优秀——你不仅需要学习一门自定义的DSL，而且还要拘泥于这套DSL提供的特性的束缚。对于像上面这样较小的普通用例来说，两种方式其实没太多选择余地，但是在编写更大的高度动态化的UI组件时，React的JavaScript方式的威力和灵活性就明显更优越了。&lt;/p&gt;
&lt;h2 id=&quot;小贴士&quot;&gt;&lt;a href=&quot;#小贴士&quot; class=&quot;headerlink&quot; title=&quot;小贴士&quot;&gt;&lt;/a&gt;小贴士&lt;/h2&gt;&lt;h3 id=&quot;避免自关闭的XHTML风格的标签&quot;&gt;&lt;a href=&quot;#避免自关闭的XHTML风格的标签&quot; class=&quot;headerlink&quot; title=&quot;避免自关闭的XHTML风格的标签&quot;&gt;&lt;/a&gt;避免自关闭的XHTML风格的标签&lt;/h3&gt;&lt;p&gt;不要用&lt;code&gt;/&amp;gt;&lt;/code&gt;来关闭标签，因为它不总是立刻就能关闭标签。当以HTML5元素对待时，&lt;code&gt;&amp;lt;foo /&amp;gt;&lt;/code&gt; 表示&lt;code&gt;&amp;lt;foo&amp;gt;&lt;/code&gt;（然而在XHTML中&lt;code&gt;&amp;lt;foo /&amp;gt;&lt;/code&gt;表示&lt;code&gt;&amp;lt;foo&amp;gt;&amp;lt;/foo&amp;gt;&lt;/code&gt;），换言之，HTML5会忽略&lt;code&gt;/&lt;/code&gt;字符。有关这个话题可以在&lt;a href=&quot;http://stackoverflow.com/questions/9845011/are-custom-elements-valid-html5/9845124#9845124&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Stackoverflow&lt;/a&gt;上查看更多讨论。还可以查看下面两处内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://riotjs.com/forum/#!/using:closing-html5-tags-with-&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用&lt;code&gt;/&amp;gt;&lt;/code&gt;关闭HTML5标签可能造成无法预料的结果&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://riotjs.com/forum/#!/using:misplaced-form-end-tag&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;放错位置的表单结束标签&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;绑定标签事件处理器到this上&quot;&gt;&lt;a href=&quot;#绑定标签事件处理器到this上&quot; class=&quot;headerlink&quot; title=&quot;绑定标签事件处理器到this上&quot;&gt;&lt;/a&gt;绑定标签事件处理器到this上&lt;/h3&gt;&lt;p&gt;绑定标签事件处理器到this上，以确保这些处理器总是和标签文本一起清除（可选的方式是使用约定俗成的&lt;code&gt;var self = this&lt;/code&gt;）。比如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;this.clear = function(e) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  dispatcher.trigger(dispatcher.CLEAR_TODOS);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;.bind(this);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用ES6中的词法作用域绑定的箭头函数也可以获得相同的效果：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;this.clear = (e) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  dispatcher.trigger(dispatcher.CLEAR_TODOS);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;关于循环项&quot;&gt;&lt;a href=&quot;#关于循环项&quot; class=&quot;headerlink&quot; title=&quot;关于循环项&quot;&gt;&lt;/a&gt;关于循环项&lt;/h3&gt;&lt;p&gt;使用&lt;code&gt;each={item in items}&lt;/code&gt;结构将当前的循环项目传递给自定义的子标签。在下面的例子中，自定义的&lt;code&gt;todo-item&lt;/code&gt;标签内的代码可以使用&lt;code&gt;opts.todo&lt;/code&gt;来获取当前的todo项：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;ul&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &amp;lt;li each=&amp;quot;&amp;#123;todo in opts.store.todos&amp;#125;&amp;quot;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;lt;todo-item store=&amp;quot;&amp;#123;parent.opts.store&amp;#125;&amp;quot; todo=&amp;quot;&amp;#123;todo&amp;#125;&amp;quot;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &amp;lt;/li&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;命名空间事件名称&quot;&gt;&lt;a href=&quot;#命名空间事件名称&quot; class=&quot;headerlink&quot; title=&quot;命名空间事件名称&quot;&gt;&lt;/a&gt;命名空间事件名称&lt;/h3&gt;&lt;p&gt;使用命名空间加冒号的约定来组织应用的事件名称，比如&lt;code&gt;admin:edit&lt;/code&gt;，&lt;code&gt;admin:delete&lt;/code&gt;，&lt;code&gt;admin:new&lt;/code&gt;等。&lt;/p&gt;
&lt;h3 id=&quot;可以在CSS文件中使用自定义标签&quot;&gt;&lt;a href=&quot;#可以在CSS文件中使用自定义标签&quot; class=&quot;headerlink&quot; title=&quot;可以在CSS文件中使用自定义标签&quot;&gt;&lt;/a&gt;可以在CSS文件中使用自定义标签&lt;/h3&gt;&lt;p&gt;自定义标签最终会被渲染生成到DOM中，因此它们可以使用在CSS选择器和DOM审查中使用，这里是一个&lt;a href=&quot;https://github.com/srackham/riot-todo/blob/master/dist/index.css&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;例子&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;调试&quot;&gt;&lt;a href=&quot;#调试&quot; class=&quot;headerlink&quot; title=&quot;调试&quot;&gt;&lt;/a&gt;调试&lt;/h3&gt;&lt;p&gt;当用Webpack打包时你需要使用&lt;a href=&quot;https://github.com/srackham/riot-todo/blob/master/webpack.config.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;开发工具source-map配置选项&lt;/a&gt;来为你打包后的应用生成&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;source map&lt;/a&gt;文件。这使得你可以在ES6的源码文件中进行调试。&lt;/p&gt;
&lt;p&gt;当需要浏览和调试源码时，打开浏览器的&lt;em&gt;Sources窗口&lt;/em&gt;然后定位到&lt;code&gt;webpack:///.&lt;/code&gt;文件夹：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在Firefox中：打开Debugger（Ctrl+Shift+S）。&lt;/li&gt;
&lt;li&gt;在 Google Chrome中：打开Console（Ctrl+Shift+J）然后点击&lt;em&gt;Sources&lt;/em&gt;标签来查看源码面板。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我不是很喜欢调试程序和设置断点——大多数情况下我仅仅会有策略地在代码中放置暂时性的&lt;code&gt;console.log()&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;未来蓝图&quot;&gt;&lt;a href=&quot;#未来蓝图&quot; class=&quot;headerlink&quot; title=&quot;未来蓝图&quot;&gt;&lt;/a&gt;未来蓝图&lt;/h2&gt;&lt;p&gt;Riot（类似React）是一个UI库而不是一个框架。这非常棒（相对于大包大揽的框架来说，我更喜欢小而精的库的集合），但是对于具有一定复杂度的应用来说就需要条理清晰的高级的结构（一个体系结构）来提高可伸缩性、可发展性和可维护性。&lt;a href=&quot;https://www.npmjs.com/package/flux&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Flux&lt;/a&gt;为类似React的应用增加了体系结构的选择。我喜欢Flux，因为它很容易理解并且它能给人一种很直观的感觉（并非出于任何理论上的信仰）。&lt;a href=&quot;https://github.com/srackham/riot-todo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Riot Todo app&lt;/a&gt;使用了名为&lt;a href=&quot;https://github.com/jimsparkman/RiotControl&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RiotControl&lt;/a&gt;的Flux风格的dispatcher（经过轻微修改）来实现Flux体系结构。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;原文出处：&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;srackham&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;http://blog.srackham.com/posts/riot-es6-webpack-apps/&quot; target=&quot;_bla
    
    </summary>
    
      <category term="技术研究" scheme="http://chriscindy.top/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Riot.js" scheme="http://chriscindy.top/tags/Riot-js/"/>
    
  </entry>
  
  <entry>
    <title>Composition Event</title>
    <link href="http://chriscindy.top/2016/07/11/Composition-Event/"/>
    <id>http://chriscindy.top/2016/07/11/Composition-Event/</id>
    <published>2016-07-11T02:26:38.000Z</published>
    <updated>2016-07-11T02:26:38.000Z</updated>
    
    <content type="html">&lt;p&gt;Composition Event，中文译为复合事件，是DOM 3级事件中新添加的一类事件类型，用于处理IME的输入序列。IME（Input Method Editor，输入法编辑器）可以让用户输入在物理键盘上找不到的字符。复合事件就是针对检测和处理这种输入而设计的。也因为以上所述原因，复合事件很少为通常使用拉丁系语言输入的开发者所知（因为拉丁字母都能通过物理键盘输入）。当然，即使是使用非拉丁系语言比如中文作为输入的开发者，也不见得知道复合事件，因为开发中用到该种事件类型的情况比较少见。&lt;/p&gt;
&lt;p&gt;IME复合系统的工作原理如下：缓存用户的键盘输入，直到一个字符被选中后才确定输入。缓存的键盘输入会暂时展示在输入框中，但不会真正被插入到DOM中。如下图所示。但是如果在复合事件的过程中改变了输入框的值（比如切换了输入法或者直接按下enter键），复合事件将提前结束，同时缓存的键盘输入值将会插入到输入框中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/72f96cbagw1f5pr65nfcxj20zi09cwfq.jpg&quot; alt=&quot;10:21:17.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;复合事件类型包含以下几种事件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;compositionstart：当IME的文本复合系统打开时触发。&lt;/li&gt;
&lt;li&gt;compositionend：在IME的文本复合系统关闭即用户选中了字符并确定输入时触发，表示返回正常键盘的输入状态。&lt;br&gt;-compositionupdate：在compositionstart事件触发后，compositionend事件触发前这段时间内，每次向输入字段中进行输入时均会触发。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：input事件将在复合事件后触发。&lt;/p&gt;
&lt;p&gt;但是，实际情况与理想还是有一定距离的，复合事件的兼容性比较一般。下图是MDN中列出的兼容性表现，详情可见&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MDN&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/72f96cbagw1f5pr91ls0nj21420dg75t.jpg&quot; alt=&quot;10:24:08.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/72f96cbagw1f5pr973kpuj214s0dtabp.jpg&quot; alt=&quot;10:24:13.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;综上，在使用复合事件处理input相关的问题时，仍然需要慎重。&lt;/p&gt;
&lt;p&gt;注：本文参考尤雨溪博客中&lt;a href=&quot;http://blog.evanyou.me/2014/01/03/composition-event/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DOM COMPOSITION EVENTS COMPATIBILITY NOTES&lt;/a&gt;一文。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Composition Event，中文译为复合事件，是DOM 3级事件中新添加的一类事件类型，用于处理IME的输入序列。IME（Input Method Editor，输入法编辑器）可以让用户输入在物理键盘上找不到的字符。复合事件就是针对检测和处理这种输入而设计的。也因为
    
    </summary>
    
      <category term="技术研究" scheme="http://chriscindy.top/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="JavaScript" scheme="http://chriscindy.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>两个Git帐号如何在一台电脑上共存</title>
    <link href="http://chriscindy.top/2016/07/08/%E4%B8%A4%E4%B8%AAGit%E5%B8%90%E5%8F%B7%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%8A%E5%85%B1%E5%AD%98/"/>
    <id>http://chriscindy.top/2016/07/08/两个Git帐号如何在一台电脑上共存/</id>
    <published>2016-07-08T08:11:59.000Z</published>
    <updated>2016-07-08T08:24:38.000Z</updated>
    
    <content type="html">&lt;p&gt;相信很多开发者都会遇到在自己的电脑上使用不止一个git帐号的情况。一个一般是自己的github帐号，另一个则是公司的git帐号，比如gitlab、bitbucket等。如果采用https方式通信，那么git帐号间不会有冲突，但你在每次pull、push的时候都要输入帐号密码，十分繁琐。而且当代码库达到十分庞大的规模时，如果仍然采用https方式，在git pull时可能出现超时不响应的情况，此时只能采用ssh方式。ssh在配置完ssh key后使用起来很方便，但是git帐号间可能出现冲突，这时候该如何解决呢？&lt;/p&gt;
&lt;p&gt;配置ssh key的方式此处不再赘述，假设.ssh文件夹下有id_rsa、id_rsa.pub、didi_id_rsa、didi_id_rsa.pub，分别对应个人github帐号私钥公钥以及公司git帐号私钥公钥。如果不进行设置，使用github账号时没有问题，但是使用公司账号时，由于默认情况下私钥存放在id_rsa文件中，因此git仍会尝试用id_rsa中而不是didi_id_rsa中的私钥去与服务器上添加的公钥进行比对，自然而然会报错。通常这种情况下git会让你输入密码，笔者连续三次输入密码错误（其实根本不知道该密码为何物），报错，Permission denied。&lt;/p&gt;
&lt;p&gt;网络上的解决方案普遍为在ssh的配置文件中加入以下字段：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Host github.com&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; hostname gitlab.zjut.com&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; User Boy-A&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; IdentityFile /User/&amp;lt;yourusername&amp;gt;/.ssh/id_rsa&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Host git.xiaojukeji.com&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; hostname git.xiaojukeji.com&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; User Boy-B&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; IdentityFile /User/&amp;lt;yourusername&amp;gt;/.ssh/didi_id_rsa&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该文件的主要作用就是指明各个git帐号对应的User以及IdentityFile的文件位置。当配置完毕后，在各个项目repo中应用自己的用户名以及邮箱：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1.取消global&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;git config --global --unset user.name&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;git config --global --unset user.email&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2.设置每个项目repo的自己的user.email&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;git config  user.email &amp;quot;xxxx@xx.com&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;git config  user.name &amp;quot;ddfe&amp;quot;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如此，各个git帐号间就可以“井水不犯河水”了。&lt;/p&gt;
&lt;p&gt;但是，最麻烦的地方其实并不在这里，而是这个配置文件究竟位于何处。根据网友的分享，Window系统中，该配置信息存放在名为config的文件中，位置在~/.ssh/目录下，而在Linux/Unix系统中配置信息则保存在ssh_config文件中，至于位置，众说纷纭。笔者使用的是macOS系统，尝试用“ssh -vT git@git.xiaojukeji.com”去查看ssh连接主机的debug信息，终于发现了头绪，debug信息的第二行如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;debug1: Reading configuration data /etc/ssh/ssh_config&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;终于找到了文件的位置！修改之，大功告成！&lt;/p&gt;
&lt;h2 id=&quot;总结：&quot;&gt;&lt;a href=&quot;#总结：&quot; class=&quot;headerlink&quot; title=&quot;总结：&quot;&gt;&lt;/a&gt;总结：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;使用命令“ssh -vT git@xxx.com”查看ssh_config文件的位置&lt;/li&gt;
&lt;li&gt;进入ssh_config文件，配置各个git帐号的User以及IdentityFIle&lt;/li&gt;
&lt;li&gt;在各个项目中配置好user.name以及user.email&lt;/li&gt;
&lt;li&gt;在各个git帐号间尽情穿梭吧~&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;相信很多开发者都会遇到在自己的电脑上使用不止一个git帐号的情况。一个一般是自己的github帐号，另一个则是公司的git帐号，比如gitlab、bitbucket等。如果采用https方式通信，那么git帐号间不会有冲突，但你在每次pull、push的时候都要输入帐号密码
    
    </summary>
    
      <category term="解决方案" scheme="http://chriscindy.top/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="Git" scheme="http://chriscindy.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://chriscindy.top/2016/07/08/Hello%20World/"/>
    <id>http://chriscindy.top/2016/07/08/Hello World/</id>
    <published>2016-07-08T03:25:04.000Z</published>
    <updated>2016-07-08T08:32:54.000Z</updated>
    
    <content type="html">&lt;p&gt;恩，这是hexo建好后默认的第一篇博文，没有想过删除它，因为我觉得对于这样一个有纪念意义的时刻，应该有一篇文章能够记录一下。&lt;/p&gt;
&lt;p&gt;没错，终于有自己可以写文章的地方了，感觉就像是终于有了一个只属于自己的小窝，这种美妙的感觉难以言表。从今以后，就在这里分享技术，感悟生活啦。&lt;/p&gt;
&lt;p&gt;配置Hexo的过程并不困难，就是有些繁琐。之前选用了一个比较小众但很清新的主题&lt;a href=&quot;https://github.com/ahonn/hexo-theme-even&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;even&lt;/a&gt;，但是发现有各种功能上的缺失，终于还是决定回到最强势最完善的NexT上，折腾一圈，安装完各种插件，看着博客的功能慢慢丰满起来，虽然没有太大的难度，但是仍有一种满满的成就感。&lt;/p&gt;
&lt;p&gt;所以，Hello World，向成为前端大拿努力！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;恩，这是hexo建好后默认的第一篇博文，没有想过删除它，因为我觉得对于这样一个有纪念意义的时刻，应该有一篇文章能够记录一下。&lt;/p&gt;
&lt;p&gt;没错，终于有自己可以写文章的地方了，感觉就像是终于有了一个只属于自己的小窝，这种美妙的感觉难以言表。从今以后，就在这里分享技术，感悟生
    
    </summary>
    
      <category term="生活感悟" scheme="http://chriscindy.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="里程碑" scheme="http://chriscindy.top/tags/%E9%87%8C%E7%A8%8B%E7%A2%91/"/>
    
  </entry>
  
</feed>
