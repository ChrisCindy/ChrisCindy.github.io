<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sunflower-&gt;FE</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chriscindy.top/"/>
  <updated>2017-04-27T07:16:14.000Z</updated>
  <id>http://chriscindy.top/</id>
  
  <author>
    <name>ChrisCindy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《图解HTTP》梳理（二）</title>
    <link href="http://chriscindy.top/post/reading-notes-two-of-learning-HTTP-together/"/>
    <id>http://chriscindy.top/post/reading-notes-two-of-learning-HTTP-together/</id>
    <published>2017-04-27T07:14:53.000Z</published>
    <updated>2017-04-27T07:16:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第四章-返回结果的-HTTP-状态码"><a href="#第四章-返回结果的-HTTP-状态码" class="headerlink" title="第四章 返回结果的 HTTP 状态码"></a>第四章 返回结果的 HTTP 状态码</h2><ul>
<li>状态码类别</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody>
<tr>
<td>1XX</td>
<td>Informational（信息性状态码）</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器处理请求出错</td>
</tr>
</tbody>
</table>
<ul>
<li>代表性状态码<ul>
<li>200 OK</li>
<li>204 No Content：一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用</li>
<li>206 Partial Content：响应报文中包含由 Content-Range 指定范围的实体内容</li>
<li>301 Moved Permanently：永久性重定向。请求的资源已被分配了新的 URI</li>
<li>302 Found：临时性重定向。希望用户本次能使用新的 URI 访问</li>
<li>303 See Other：该状态码和 302 有着相同功能，但是 303 明确表示客户端应当采用 GET 方法获取资源</li>
<li>备注：301、302、303 响应码返回时，几乎所有的浏览器都会把 POST 改为 GET，并删除请求报文内的主体，之后请求会自动再次发送。</li>
<li>304 Not Modified：客户端发送附带条件的请求（采用 GET 方法的请求报文中包含 If-Match/If-Modified-Since/If-None-Match/If-Range/If-Unmoodified-Since 中任一首部）时，服务器允许请求访问资源，但未满足条件的情况。304 返回时不包含任何响应的主体部分。304 与重定向无关系。</li>
<li>307 Temporary Redirect：临时重定向。与 302 含义相同。302 标准禁止将 POST 变换成 GET，但是使用时大家并不遵守。而 307 会遵守浏览器标准，不会将 POST 变为 GET。</li>
<li>400 Bad Request：报文中存在语法错误，浏览器无法理解，但会像对待 200 OK 一样对待该状态码。</li>
<li>401 Unauthorized：发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。此外，如果之前已经进行过 1 次请求，则表示用户认证失败。返回 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。</li>
<li>403 Forbidden：服务器拒绝访问，原因可能是未获得文件系统的访问授权，访问权限出现某些问题等。</li>
<li>404 Not Found：服务器上无法找到请求的资源，也可以在服务器端拒绝请求且不想说明理由时使用。</li>
<li>500 Internal Server Error：服务器端执行请求时发生错误。</li>
<li>503 Service Unavailable：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li>
</ul>
</li>
<li>注：不少返回的状态码响应都是错的，比如 Web 应用程序内部发生错误，状态码依然返回 200 OK。</li>
</ul>
<h2 id="第五章-与-HTTP-协作的-Web-服务器"><a href="#第五章-与-HTTP-协作的-Web-服务器" class="headerlink" title="第五章 与 HTTP 协作的 Web 服务器"></a>第五章 与 HTTP 协作的 Web 服务器</h2><ul>
<li>相同的 IP 地址下，虚拟主机可以寄存多个不同主机名和域名的 Web 网站。发送 HTTP 请求时，必须在 Host 首部内完整指定主机名或域名的 URI。</li>
<li>HTTP 通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，如代理、网关和隧道。<ul>
<li>代理：一种具有转发功能的应用程序；不改变请求 URI；每次通过代理服务器转发请求或者响应时，会追加写入 Via 首部信息（Via: proxy 2, proxy1）；代理可级联；<ul>
<li>使用代理服务器的理由包括：<ul>
<li>利用缓存技术减少网络带宽的流量。</li>
<li>组织内部针对特定网站的访问控制</li>
<li>以获取日志为主要目的</li>
</ul>
</li>
<li>代理有多种使用方法，按两种基准分类：一种时是否使用缓存，另一种是是否会修改报文<ul>
<li>缓存代理：代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上</li>
<li>透明代理：转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy），反之为非透明代理</li>
</ul>
</li>
</ul>
</li>
<li>网关：转发其他服务器通信数据的服务器。接收从客户端发送来的请求时，其就像自己拥有资源的源服务器一样对请求进行处理；利用网关可以由 HTTP 请求转化为其他协议通信；网关可以提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全；网关可以连接数据库，使用 SQL 语句查询数据</li>
<li>隧道：在相隔很远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序；可使用 SSL 等加密手段</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第四章-返回结果的-HTTP-状态码&quot;&gt;&lt;a href=&quot;#第四章-返回结果的-HTTP-状态码&quot; class=&quot;headerlink&quot; title=&quot;第四章 返回结果的 HTTP 状态码&quot;&gt;&lt;/a&gt;第四章 返回结果的 HTTP 状态码&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://chriscindy.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="HTTP" scheme="http://chriscindy.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>《图解 HTTP》 梳理（一）</title>
    <link href="http://chriscindy.top/post/reading-notes-one-of-learning-HTTP-together/"/>
    <id>http://chriscindy.top/post/reading-notes-one-of-learning-HTTP-together/</id>
    <published>2017-04-26T07:22:26.000Z</published>
    <updated>2017-04-27T07:15:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章-了解-Web-及网络基础"><a href="#第一章-了解-Web-及网络基础" class="headerlink" title="第一章 了解 Web 及网络基础"></a>第一章 了解 Web 及网络基础</h2><p>略</p>
<h2 id="第二章-简单的-HTTP-协议"><a href="#第二章-简单的-HTTP-协议" class="headerlink" title="第二章 简单的 HTTP 协议"></a>第二章 简单的 HTTP 协议</h2><ul>
<li>HTTP/1.1 所有连接默认为持久连接，但 HTTP/1.0 未标准化</li>
<li>管线化技术出现后，不需要等待响应即可直接发送下一个请求</li>
<li>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。服务器发送的响应报文中含有 Set-Cookie 的首部字段时，客户端保存 Cookie。此后客户端在请求报文中会自动加上 Cookie 值</li>
</ul>
<h2 id="第三章-HTTP-报文内的-HTTP-信息"><a href="#第三章-HTTP-报文内的-HTTP-信息" class="headerlink" title="第三章 HTTP 报文内的 HTTP 信息"></a>第三章 HTTP 报文内的 HTTP 信息</h2><ul>
<li><p>编码提升传输速率，常用的内容编码有以下几种：gzip（GNU zip）、compress（UNIX 系统的标准压缩）、deflate（zlib）、identify（不进行编码）</p>
</li>
<li><p>分割发送的分块传输编码（Chunked Transfer Coding），其将实体主体分成多个部分，每一部分均通过十六进制来标记块的大小，最后一块使用『0（CR+LF）』来标记。</p>
</li>
<li><p>MIME（多用途因特网邮件扩展）机制，允许邮件处理文本、图片、视频等多个不同类型的数据。MIME 扩展中使用一种称为多部分对象集合（Multipart）的方法，用来容纳多份不同类型的数据。</p>
</li>
<li><p>mulitpart 包含的对象如下：</p>
<ul>
<li>multipart/form-data：在 Web 表单文件上传时使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Content-Type: multipart/form-data; boundary=AaB03x</div><div class="line"></div><div class="line">--AaB03x</div><div class="line">Content-Disposition: form-data; name=&quot;field1&quot;</div><div class="line"></div><div class="line">Joe Blow</div><div class="line">--AaB03x</div><div class="line">Content-Disposition: form-data; name=&quot;pics&quot;; filename=&quot;file1.txt&quot;</div><div class="line">Content-Type: text/plain</div><div class="line"></div><div class="line">...（file1.txt的数据）...</div><div class="line">--AaB03x--</div></pre></td></tr></table></figure>
<ul>
<li>multipart/byteranges：状态码 206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 206 Partial Content</div><div class="line">Date: Fri, 13 Jul 2012 02:45:26v GMT</div><div class="line">Last-Modified: Fri, 31 Aug 2007 02:02:20 GMT</div><div class="line">Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES</div><div class="line"></div><div class="line">--THIS_STRING_SEPARATES</div><div class="line">Content-Type: application/pdf</div><div class="line">Content-Range: bytes 500-999/8000</div><div class="line"></div><div class="line">...(范围指定的数据)...</div><div class="line"></div><div class="line">--THIS_STRING_SEPARATES</div><div class="line">Content-Type: application/pdf</div><div class="line">Content-Range: bytes 7000-7999/8000</div><div class="line"></div><div class="line">...(范围指定的数据)...</div><div class="line">--THIS_STRING_SEPARATES--</div></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>使用 boundary 字符串来划分 multipart 指明的各类实体，在其指定的各个实体的起始行之前插入『—』标记（如 –AaB03x），在对应的字符串的最后插入『–』标记作为结束（如 –AaB03x—）。</li>
</ul>
</li>
<li><p>范围请求（Range Request）：指定范围发送的请求。执行范围请求时，用到首部字段 Range 来指定资源的 byte 范围：</p>
<ul>
<li>5001~10000 字节</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Range: bytes=5001-10000</div></pre></td></tr></table></figure>
<ul>
<li>从 5001 字节之后全部的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Range: bytes=5001-</div></pre></td></tr></table></figure>
<ul>
<li>从一开始到 3000 字节和 5000~7000 字节的多重范围</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Range: bytes=-3000, 5000-7000</div></pre></td></tr></table></figure>
<ul>
<li>说明：针对范围请求，响应返回 206 Partial Content 的响应报文。对于多重范围的范围请求，响应会在首部字段 Content-Type 标明 multipart/byteranges 后 返回响应报文。如果服务器无法响应范围请求，则会返回 200 OK。</li>
</ul>
</li>
<li><p>内容协商（Content Negotiation）：客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最合适的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准，包含在请求报文中的某些首部字段用于标识这些判断标准：</p>
<ul>
<li>Accept</li>
<li>Accept-Charset</li>
<li>Accept-Encoding</li>
<li>Accept-Language</li>
<li>Content-Language</li>
</ul>
</li>
<li><p>内容协商技术的 3 种类型：</p>
<ul>
<li>服务器驱动协商</li>
<li>客户端驱动协商</li>
<li>透明协商</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一章-了解-Web-及网络基础&quot;&gt;&lt;a href=&quot;#第一章-了解-Web-及网络基础&quot; class=&quot;headerlink&quot; title=&quot;第一章 了解 Web 及网络基础&quot;&gt;&lt;/a&gt;第一章 了解 Web 及网络基础&lt;/h2&gt;&lt;p&gt;略&lt;/p&gt;
&lt;h2 id=&quot;
    
    </summary>
    
      <category term="读书笔记" scheme="http://chriscindy.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="HTTP" scheme="http://chriscindy.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>慎用 for..of，Babel 不是万能的！</title>
    <link href="http://chriscindy.top/post/be-careful-with-for...of/"/>
    <id>http://chriscindy.top/post/be-careful-with-for...of/</id>
    <published>2017-04-18T08:02:25.000Z</published>
    <updated>2017-04-21T02:43:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>ES6 借鉴了其他编程语言的特性，为 JavaScript 带来了 for…of 循环语法，用于遍历数组等数据结构。当然，由于是 ES6 的特性，我们使用 for…of 的时候，依然要借助 Babel 进行转码。我们来看看 Babel 是如何处理 for…of 代码的。</p>
<p>ES6 原生代码如下。为避免干扰，这里不使用 ES6 其他特性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> names = [<span class="string">'paul'</span>, <span class="string">'jordan'</span>, <span class="string">'griffin'</span>];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">of</span> names) &#123;</div><div class="line">  <span class="built_in">console</span>.log(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Babel 转码后结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> names = [<span class="string">'paul'</span>, <span class="string">'jordan'</span>, <span class="string">'griffin'</span>];</div><div class="line"><span class="keyword">var</span> _iteratorNormalCompletion = <span class="literal">true</span>;</div><div class="line"><span class="keyword">var</span> _didIteratorError = <span class="literal">false</span>;</div><div class="line"><span class="keyword">var</span> _iteratorError = <span class="literal">undefined</span>;</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> _iterator = names[<span class="built_in">Symbol</span>.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = <span class="literal">true</span>) &#123;</div><div class="line">    <span class="keyword">var</span> name = _step.value;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(name);</div><div class="line">  &#125;</div><div class="line">&#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">  _didIteratorError = <span class="literal">true</span>;</div><div class="line">  _iteratorError = err;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">if</span> (!_iteratorNormalCompletion &amp;&amp; _iterator.return) &#123;</div><div class="line">      _iterator.return();</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">if</span> (_didIteratorError) &#123;</div><div class="line">      <span class="keyword">throw</span> _iteratorError;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们观察到 Babel 转换后的代码里第 9 行仍然出现了 ES6 的特性——Symbol.iterator，这是为什么呢？我们先来探究一下 for…of 的实现原理。</p>
<p>for…of 在对数据结构进行循环时，背后实际上是调用了该数据结构的 Iterator 接口。一种数据结构只要具有 Iterator 接口，我们就可以认为该数据结构是“<strong>可遍历的</strong>”（iterable）。原生数据结构中具有“可遍历”属性的包括数组、Set、Map、以及字符串之类的类数组对象等。具体到 Iterator 接口上，ES6 规定，默认的 Iterator 接口部署在该数据结构的 Symbol.iterator 属性上（Symbol 是 ES6 新增的原始数据类型，表示独一无二的值，具体参见 ES6 文档），该属性本身是一个函数，执行该函数会返回一个指针对象。该指针对象称为<strong>遍历器</strong>，其必须包含一个 next 方法，不断调用 next 方法可以使指针从数据结构的第一个成员一直指向最后一个成员，即调用 next 方法会返回数据结构当前成员的信息，该信息为一个对象，包含 value 和 done 两个属性。value 是当前成员的值，done 是一个布尔值，表示遍历是否结束。以上的理论有点抽象，我们来模拟一个“可遍历”的数据结构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> iterableData = &#123;</div><div class="line">  <span class="attr">data</span>: [<span class="string">'paul'</span>,<span class="string">'jordan'</span>,<span class="string">'griffin'</span>,<span class="string">'redick'</span>,<span class="string">'rivers'</span>],</div><div class="line">  <span class="attr">dataIndex</span>: <span class="number">0</span>,</div><div class="line">  <span class="comment">//Symbol 类型的值作为对象属性时必须使用方括号结构</span></div><div class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">next</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	    <span class="keyword">return</span> &#123;</div><div class="line">		 <span class="attr">value</span>: self.data[self.dataIndex++],</div><div class="line">          <span class="attr">done</span>: self.dataIndex &lt; self.data.length? <span class="literal">false</span>: <span class="literal">true</span>	</div><div class="line">	    &#125;;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterableData) &#123;</div><div class="line">  <span class="built_in">console</span>.log(item);</div><div class="line">&#125;</div><div class="line"><span class="comment">// paul, jordan, griffin, redick, rivers</span></div></pre></td></tr></table></figure>
<p>可以看到，只要一个数据结构具有符合要求的 Symbol.iterator 属性，就可以通过 for…of 遍历（事实上，解构赋值、扩展运算符、yield* 等 ES6 特性也是调用该属性接口）。</p>
<p>现在，我们回过头来看 Babel 转换 for…of 循环的代码，其本质上还是通过调用 Iterator 接口（注意第 9 行），将 for…of 转换为传统的 for 循环，并在每次循环中调用遍历器的 next 方法来吐出数组中的值。如果在循环调用过程中出现错误，遍历器中如含有预定义的 return 函数（参见 ES6 文档中遍历器对象的规范 ），则调用之，否则直接抛出错误。</p>
<p>所以，问题就出现了，即使调用 Babel 对 for…of 循环进行转码，我们实际上还是无法完全摆脱 ES6 的特性——在不支持 Symbol 的环境下，代码仍然会报错。因为 Babel 默认只转换新的 JavaScript 句法（syntax）,而不转换 Proxy、Set、Promise、Symbol 等新的 API。所以，在对兼容性要求较高时，确实要慎重使用 for…of 语法，即使我们有 Babel 这件神兵利器。</p>
<p>实际上，要想完全抹平 ES6 特性带来的新 API 也是可行的，只要在项目中引入 babel-polyfill 并配置好即可，但是这样带来的另一个问题就是因为 babel-polyfill 本身的体积，我们的代码也会变庞大不少。所以此举有利有弊，需要根据实际情况进行权衡。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6 借鉴了其他编程语言的特性，为 JavaScript 带来了 for…of 循环语法，用于遍历数组等数据结构。当然，由于是 ES6 的特性，我们使用 for…of 的时候，依然要借助 Babel 进行转码。我们来看看 Babel 是如何处理 for…of 代码的。&lt;/
    
    </summary>
    
      <category term="理论学习" scheme="http://chriscindy.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Babel" scheme="http://chriscindy.top/tags/Babel/"/>
    
      <category term="ES6" scheme="http://chriscindy.top/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>如何终止 JS 脚本的运行</title>
    <link href="http://chriscindy.top/post/how-to-stop-js-script/"/>
    <id>http://chriscindy.top/post/how-to-stop-js-script/</id>
    <published>2017-04-13T02:20:22.000Z</published>
    <updated>2017-04-21T02:43:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在开发一个 JSSDK 的时候有一个需求：为了检测当前环境中是否已经加载过该脚本，需要在脚本开始运行时加入一层判断，如果检测到已存在该脚本导出的变量，则终止脚本的后续运行，否则再执行后续逻辑。 那么便碰上了本文标题的问题：如何终止 JS 脚本的运行？</p>
<p>在很多其他语言比如 PHP 当中，存在 exit 函数来中止程序的运行。很遗憾的是 JavaScript 没有。因此我们需要自己模拟出这么一个 “exit” 功能。</p>
<p>我们知道，<code>break</code>是 JavaScript 中合法的中断语句，但其只适用于循环和 switch 语句，此路不通。除了 <code>break</code>，JavaScript 还可以通过 <code>return</code> 来显示终止一个函数的执行，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'executed'</span>);</div><div class="line">  <span class="keyword">return</span>;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'not executed'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>return</code> 语句之后的代码将不会被执行。看起来可以用这个方式来达到我们终止 JS 脚本运行的目的。</p>
<p>那么我们来试试看在脚本中使用 <code>return</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// index.js</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"OK,let's start"</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'first step'</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'second step'</span>);</div><div class="line"><span class="keyword">return</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'you cannot see me'</span>);</div></pre></td></tr></table></figure>
<p>我们把脚本丢到浏览器里去执行一下，发现报错了，信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Uncaught SyntaxError: Illegal return statement</div></pre></td></tr></table></figure>
<p>这里我们犯了一个严重的错误：<code>return</code> 只能应用于函数内部，而脚本本身并不是函数。这里大家可能很自然的想到，把脚本包裹在一个自执行匿名函数（IIFE）里不就行了。我们尝试一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// index.js</span></div><div class="line"></div><div class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"OK,let's start"</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'first step'</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'second step'</span>);</div><div class="line">  <span class="keyword">return</span>;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'you cannot see me'</span>);</div><div class="line"></div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>浏览器的执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">OK,let&apos;s start</div><div class="line">first step</div><div class="line">second step</div></pre></td></tr></table></figure>
<p>OK，我们的目标达成，成功终止了脚本的运行。确实，将代码包裹在 IIFE 中可以随时控制脚本运行是否终止，但是这是否有点麻烦呢？固然我们有 Rollup 一类的工具可以将代码打包成为 IIFE 形式，但毕竟多一步操作，还需要对构建工具进行配置，在小项目里成本过高。而且，并不是所有需要中断程序运行的场景下都适合将代码通过 IIFE 来执行。因此，这一方式可行，但不够简洁。</p>
<p>实际可行的方法是利用错误来终止 JavaScript 程序的运行。这里的错误包括语法错误、变量错误、程序错误等等，我们只需要用 <code>throw new Error()</code> 的方式抛出错误，就能达到目的。在抛出该错误之前的代码可正常执行不受影响，而在其之后的代码则不会执行。看下例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// index.js</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"OK,let's start"</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'first step'</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'second step'</span>);</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'this is my customed error'</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'you cannot see me'</span>);</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1fel7101qkuj30jw05kt9a.jpg" alt=""></p>
<p>OK，目标达成。你可以在你的程序中任意想中止的地方抛出错误，然后就能达到 exit 的目的。</p>
<p>但是，进一步思考，为什么 JavaScript 没有提供类似其他语言的 exit 函数呢？实际上，这一切都是因为 JavaScript 是单线程语言，基于代码可以异步执行的考虑，才没有设置 exit 功能。那么，是不是在包含异步执行的代码中，我们的抛出错误的方法实际上也不能立刻终止程序呢？答案是肯定的，我们看下例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// index.js</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"OK,let's start"</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'first step'</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'second step'</span>);</div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'you still can see me'</span>);</div><div class="line">&#125;, <span class="number">1000</span>);</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'this is my customed error'</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'you cannot see me'</span>);</div></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1fel7914um4j30je06swf8.jpg" alt=""></p>
<p>“you still can see me” 延迟了一秒输出，但是仍然输出了，说明我们的 <code>throw new Error</code> 并没有立刻中止异步代码的执行。实际上这也是必然的，感兴趣的同学可以去研究一下 JavaScript 的运行机制以及 Event Loop 相关的内容。</p>
<p>最后，我们得出结论，JavaScript 的主线程同步任务可以通过抛出错误的方式立即中止，但是异步任务并不会受到影响。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在开发一个 JSSDK 的时候有一个需求：为了检测当前环境中是否已经加载过该脚本，需要在脚本开始运行时加入一层判断，如果检测到已存在该脚本导出的变量，则终止脚本的后续运行，否则再执行后续逻辑。 那么便碰上了本文标题的问题：如何终止 JS 脚本的运行？&lt;/p&gt;
&lt;p&gt;在很
    
    </summary>
    
      <category term="解决方案" scheme="http://chriscindy.top/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="JavaScript" scheme="http://chriscindy.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Vue 插件开发入门</title>
    <link href="http://chriscindy.top/post/Vue-plugin-development-introduction/"/>
    <id>http://chriscindy.top/post/Vue-plugin-development-introduction/</id>
    <published>2017-04-01T07:47:42.000Z</published>
    <updated>2017-04-21T02:31:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>相对<strong>组件</strong>来说，Vue 的<strong>插件</strong>开发受到的关注要<strong>少</strong>一点。但是插件的功能是十分强大的，能够完成许多 Vue 框架本身不具备的功能。</p>
<p>大家一般习惯直接调用现成的插件，比如官方推荐的 <strong>vue-router</strong>、<strong>vue-touch</strong> 等。<br>下面就看一下 Vue 的插件开发如何入门。</p>
<p>首先我们简单回顾一下 Vue.js 官方文档中对于插件开发的描述。</p>
<p>Vue 的插件必须提供一个公开方法 <strong>install</strong>，该方法会在你使用该插件，也就是 <code>Vue.use(yourPlugin)</code> 时被调用，相当于是一个插件的注册或者声明。<code>install</code> 接受 Vue 构造器作为第一个参数，并且有一个可选的选项对象作为第二个参数，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">yourPlugin.install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue, options</span>) </span>&#123;</div><div class="line">  <span class="comment">// 1. 添加全局方法或属性</span></div><div class="line">  Vue.myGlobalMethod = ...</div><div class="line">  <span class="comment">// 2. 添加全局资源</span></div><div class="line">  Vue.directive(<span class="string">'my-directive'</span>, &#123;&#125;)</div><div class="line">  <span class="comment">// 3. 添加实例方法</span></div><div class="line">  Vue.prototype.$myMethod = ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>插件在使用时有<strong>两种</strong>方式：</p>
<blockquote>
<p>第一种是如上述提到的，可以通过 <code>Vue.use(yourPlugin)</code> 全局方法进行调用。<br>进行 Vue 的大型项目开发时，如果用 vue-cli 生成项目目录结构，<code>Vue.use()</code> 方法一般在 main.js 中调用。</p>
<p>第二种实际上是插件本身帮你完成了 <code>Vue.use()</code>的调用。<br>这种情况下，插件会去检测是否存在 <code>Vue</code> 全局变量，如果存在，就自动调用 <code>Vue.use()</code>。所以，如果你的项目中是使用 script 方式引入的 Vue.js（这种情况下 <code>Vue</code> 才会作为一个全局变量存在），在使用比如 vue-router 之类的插件时就可以直接引入然后使用，不用再调用 <code>Vue.use()</code>。<br>但是，在模块环境下应当始终显式调用该方法，以保证插件可以正常使用：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通过 Browserify 或 Webpack 使用 CommonJS 兼容模块</span></div><div class="line"><span class="keyword">var</span> Vue = <span class="built_in">require</span>(<span class="string">'vue'</span>)</div><div class="line"><span class="keyword">var</span> VueRouter = <span class="built_in">require</span>(<span class="string">'vue-router'</span>)</div><div class="line"><span class="comment">// 不要忘了调用此方法</span></div><div class="line">Vue.use(VueRouter)</div><div class="line"></div><div class="line"><span class="comment">// 或者可以多传入一个选项对象</span></div><div class="line"><span class="comment">// Vue.use(VueRouter, &#123; hashbang: true &#125;)</span></div></pre></td></tr></table></figure>
<p>接下来我们看一下一些官方的常用<strong>插件</strong>的实现，我们配合去除具体逻辑的源码进行一些解读：</p>
<p>1、<strong>vue-touch</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// version: 1.1.0</span></div><div class="line"><span class="comment">// vue-touch.js</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> vueTouch = &#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// 暴露出的全局配置项，也就是在调用 Vue.use(Vue, options) 时传入的第二个选项参数</span></div><div class="line">vueTouch.config = &#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// 核心部分，插件的具体逻辑均在此实现</span></div><div class="line">vueTouch.install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue</span>) </span>&#123;</div><div class="line">  Vue.directive(<span class="string">'touch'</span>, &#123;</div><div class="line">    <span class="attr">bind</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">update</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">unbind</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 支持 CommonJS</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> exports == <span class="string">"object"</span>) &#123;</div><div class="line">  <span class="built_in">module</span>.exports = vueTouch</div><div class="line"><span class="comment">// 支持 AMD</span></div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define == <span class="string">"function"</span> &amp;&amp; define.amd) &#123;</div><div class="line">  define([], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> vueTouch &#125;)</div><div class="line"><span class="comment">// Vue 是全局变量时，自动调用 Vue.use()</span></div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.Vue) &#123;</div><div class="line">  <span class="built_in">window</span>.VueTouch = vueTouch</div><div class="line">  Vue.use(vueTouch)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2、<strong>vue-router</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// version: 0.7.13</span></div><div class="line"><span class="comment">// src/index.js</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> Vue</div><div class="line"></div><div class="line"><span class="comment">// 封装为 ES6 class</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span> </span>&#123;</div><div class="line">  <span class="comment">// 可传入全局配置项</span></div><div class="line">  <span class="keyword">constructor</span>(&#123;</div><div class="line">    hashbang = <span class="literal">true</span>,</div><div class="line">    abstract = <span class="literal">false</span>,</div><div class="line">    history = <span class="literal">false</span>,</div><div class="line">    saveScrollPosition = <span class="literal">false</span>,</div><div class="line">    transitionOnLoad = <span class="literal">false</span>,</div><div class="line">    suppressTransitionError = <span class="literal">false</span>,</div><div class="line">    root = <span class="literal">null</span>,</div><div class="line">    linkActiveClass = <span class="string">'v-link-active'</span></div><div class="line">  &#125; = &#123;&#125;) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 避免重复 install，设立 flag</span></div><div class="line">Router.installed = <span class="literal">false</span></div><div class="line">Router.install = <span class="function"><span class="keyword">function</span> (<span class="params">externalVue</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (Route.installed) &#123;</div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line">  Vue = externalVue</div><div class="line"></div><div class="line">  <span class="comment">// install 的具体逻辑，此处省略</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="comment">// install 完毕</span></div><div class="line">  Router.installed = <span class="literal">true</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 同样，Vue 作为全局变量时自动 install</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">window</span>.Vue) &#123;</div><div class="line">  <span class="built_in">window</span>.Vue.use(Router)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Router</div></pre></td></tr></table></figure>
<p>3、 <strong>vue-resource</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// version: 1.0.3</span></div><div class="line"><span class="comment">// src/index.js</span></div><div class="line"></div><div class="line"><span class="comment">// install 方法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">plugin</span>(<span class="params">Vue</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (plugin.installed) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 插件核心逻辑，此处省略</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 同上，Vue 是全局变量时，自动 install</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">window</span>.Vue) &#123;</div><div class="line">    <span class="built_in">window</span>.Vue.use(plugin);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> plugin;</div></pre></td></tr></table></figure>
<p>看完以上三个官方例子，相信各位已经对 Vue 的插件开发过程有了一定的了解，大家就可以根据自己的需要为 Vue 增加各种全局功能了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相对&lt;strong&gt;组件&lt;/strong&gt;来说，Vue 的&lt;strong&gt;插件&lt;/strong&gt;开发受到的关注要&lt;strong&gt;少&lt;/strong&gt;一点。但是插件的功能是十分强大的，能够完成许多 Vue 框架本身不具备的功能。&lt;/p&gt;
&lt;p&gt;大家一般习惯直接调用现成的插件，
    
    </summary>
    
      <category term="技术使用" scheme="http://chriscindy.top/categories/%E6%8A%80%E6%9C%AF%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="Vue.js" scheme="http://chriscindy.top/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 协议如何实现文件下载功能</title>
    <link href="http://chriscindy.top/post/how-to-download-files-by-HTTP/"/>
    <id>http://chriscindy.top/post/how-to-download-files-by-HTTP/</id>
    <published>2017-03-03T07:35:58.000Z</published>
    <updated>2017-04-21T02:35:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做的一个项目需要自己搭建 node 服务端作中间层来转发请求与响应，原本倒也无甚难度，但是在中转一个返回内容是 excel 文件时遇到了一些问题。当然后来这个问题解决了，node 层对后端返回的响应不作处理，直接利用 pipe 穿透到前端即可（当然，用 node 改造一下再转发也是可以的，只是不如直接穿透方便）。今天想谈谈的是 http 响应头在返回数据是一个需要下载的文件时，应该是什么样子的。</p>
<p>http 协议实现文件下载时，需要在服务器设置好相关响应头，并使用二进制传输文件数据，而客户端（浏览器）会根据响应头接收文件数据。在 http 响应报文中，<code>Content-type</code> 和 <code>Content-Disposition</code> 是最关键的两个响应头。我们知道，通常情况下，前后端进行 ajax 交互时，后端返回前端的数据格式为 json（或者 xml）。这个时候响应报文里 <code>Content-type</code> 一般是 <code>text/html</code>、<code>text/plain</code> 或者 <code>application/json</code>，并且不会出现 <code>Content-Disposition</code> 头。但在下载文件时，<code>Content-type</code> 需要设置为 <code>application/octet-stream</code>，该 MIME 类型在 RFC 1341 中定义，表示响应实体部分是未分类的二进制数据；<code>Content-Disposition</code> 则需要设置为 <code>attachment; filename=yourFileName.yourFileExtension</code>。客户端（浏览器）在接收到这个响应之后，<code>Content-Type: application/octet-stream</code> 告诉客户端这是一个二进制文件，<code>Content-Disposition</code> 告诉客户端这是一个需要下载的附件并告诉浏览器该附件默认的文件名。如果不添加 <code>Content-Disposition</code> 响应头，浏览器可能会下载或显示文件内容，不同浏览器的处理有所不同。</p>
<p>在设置 <code>Content-type</code> 时，除了设置 <code>application/octet-stream</code>，也可以设置更为具体的文件类型，比如如果下载文件为微软的 word 文件，<code>Content-type</code> 就可以设置为 <code>application/msword</code>。一般来说 web 服务器比如 Nginx 会自动根据传输的文件类型来选择相应的 <code>Content-type</code>（需要先配置好映射关系）。当然，在 Web 程序中也可以手动设置。比如在 node 中就可以使用 mime 包来完成这个工作。</p>
<p>以上就是基本的 http 协议实现文件下载功能的方式。如果还要进一步实现断点续传等功能，需要设置 <code>Content-range</code>，这里就不展开了。</p>
<p>参考文献：《HTTP权威指南》、《图解HTTP》</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做的一个项目需要自己搭建 node 服务端作中间层来转发请求与响应，原本倒也无甚难度，但是在中转一个返回内容是 excel 文件时遇到了一些问题。当然后来这个问题解决了，node 层对后端返回的响应不作处理，直接利用 pipe 穿透到前端即可（当然，用 node 改造
    
    </summary>
    
      <category term="理论学习" scheme="http://chriscindy.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="HTTP" scheme="http://chriscindy.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Vuex 实战</title>
    <link href="http://chriscindy.top/post/Vuex-practice/"/>
    <id>http://chriscindy.top/post/Vuex-practice/</id>
    <published>2017-03-03T07:31:39.000Z</published>
    <updated>2017-04-21T02:30:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>Vuex 作为中大型 Vue 应用中的“御用”集中数据管理工具，在实习时的公司很早就得到了广泛使用。本文旨在以尽可能简洁的文字向读者展示：如何在一个颇具规模的 Vue 应用中<strong>组织和管理 Vuex 的代码</strong>。</p>
<blockquote>
<p>注：虽然目前 Vuex 的最新版本已经来到 <strong>2.x</strong>。2.x 在1.0 的基础上进行了一些优化，提升了命名的语义化以及 增强了模块的可移植性和可组合性，但基本思想和架构并没有改变。</p>
<p>本文基于 Vuex <strong>1.0</strong> 版本，读者大可不必担心出现类似 Angular 1.x  升级到 2.x 式的断崖式更新。</p>
</blockquote>
<p>首先，介绍一下项目的背景：<br>一个采用 Vue.js 编写的富交互的 H5 编辑器，由于各个组件中的数据交互繁多，页面的生成也极度依赖存储的状态，使用 Vuex 进行管理便势在必行。<br>项目引入 Vuex 的方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'components/home/App'</span></div><div class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'vuex/editor/store'</span></div><div class="line"></div><div class="line"><span class="comment">// 在 Vue 实例的初始化中声明 store。</span></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">el</span>: <span class="string">'body'</span>,</div><div class="line">  <span class="attr">components</span>: &#123;</div><div class="line">    App</div><div class="line">  &#125;,</div><div class="line">  store</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>在根实例中注册 store 选项，这样该 store 实例会注入到根组件下的所有子组件中，方便后面我们在每个子组件中调用 store 中 state 里存储的数据。</p>
<p>然后看一下 <strong>vuex</strong> 文件夹下的目录，后面我们会逐个分析每个文件的作用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">└── editor</div><div class="line"></div><div class="line">    ├── mutation-types.js</div><div class="line">    ├── actions</div><div class="line">    │   └── index.js</div><div class="line">    ├── mutations</div><div class="line">    │   └── index.js</div><div class="line">    ├── plugins</div><div class="line">    │   └── index.js</div><div class="line">    ├── state</div><div class="line">    │   └── index.js</div><div class="line">    └── store</div><div class="line">        └── index.js</div></pre></td></tr></table></figure>
<p>创建 store 对象的代码放在 vuex/editor/store/index.js 中，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// vuex/editor/store/index.js</span></div><div class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"><span class="keyword">import</span> state <span class="keyword">from</span> <span class="string">'vuex/editor/state'</span></div><div class="line"><span class="keyword">import</span> mutations <span class="keyword">from</span> <span class="string">'vuex/editor/mutations'</span></div><div class="line"><span class="keyword">import</span> &#123; actionLogPlugin &#125; <span class="keyword">from</span> <span class="string">'vuex/editor/plugins'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  state,</div><div class="line">  mutations,</div><div class="line">  <span class="attr">plugins</span>: [actionLogPlugin]</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</div></pre></td></tr></table></figure>
<p>这里又声明了 state 和 mutations 对象，以及声明了使用到的 plugins。plugins 后面再说，先看 state 和 mutations，相信各位读者已经对 Vuex 中各个部件的作用已经了如指掌，但是为防遗忘，还是贴一下这张图吧：</p>
<p>state 是用于存储各种状态的<strong>核心仓库</strong>，让我们一瞥 vuex/editor/state/index.js 中的内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 编辑器相关状态</span></div><div class="line"><span class="keyword">const</span> editor = &#123;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 页面相关状态</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> page = &#123;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> state = &#123;</div><div class="line">  editor,</div><div class="line">  page</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> state</div></pre></td></tr></table></figure>
<p>state 中存储了 <strong>editor</strong> 和 <strong>page</strong> 两个对象，用于存储不同模块的状态。需要说明的是，这里完全可以使用模块机制将其拆开，在 editor.js 里存储编辑器相关的 state 和 mutations，在 page.js 中存储页面相关的 state 和 mutations，以使结构更加清晰。不过这里没有使用模块机制，由于模块数量并不多，也是完全可以接受的。</p>
<p>这些 state 需要反映到组件中。</p>
<p>跳过官方文档中对为何不使用计算属性的解释，我们直接来看最佳实践：在子组件中通过 <code>vuex.getters</code> 来获取该组件需要用到的所有状态：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// src/components/h5/Navbar.vue</span></div><div class="line"></div><div class="line">...</div><div class="line">export <span class="keyword">default</span> &#123;</div><div class="line">    data () &#123;</div><div class="line">      <span class="keyword">return</span> &#123;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">methods</span>: &#123;</div><div class="line">      ...</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">vuex</span>: &#123;</div><div class="line">      <span class="attr">actions</span>: &#123;</div><div class="line">        ...</div><div class="line">      &#125;,</div><div class="line">      <span class="attr">getters</span>: &#123;</div><div class="line">        editor(state) &#123;</div><div class="line">          <span class="keyword">return</span> state.editor</div><div class="line">        &#125;,</div><div class="line">        page(state) &#123;</div><div class="line">          <span class="keyword">return</span> state.page</div><div class="line">        &#125;,</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>vuex.getters</code> 对象中，每个属性对应一个 getter 函数，该函数仅接收 store 中 state，也就是总的状态树作为唯一参数，然后返回 state 中需要的状态，然后在组件中就可以以 <code>this.editor</code> 的方式直接调用，类似计算属性。</p>
<p>再看一下 vuex/editor/mutations/index.js 中的内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> types <span class="keyword">from</span> <span class="string">'../mutation-types'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> mutations = &#123;</div><div class="line">  [types.CHANGE_LAYER_ZINDEX] (state, dir, index) &#123;</div><div class="line">    ...</div><div class="line">  &#125;,</div><div class="line">  [types.DEL_LAYER] (state, index) &#123;</div><div class="line">    ...</div><div class="line">  &#125;,</div><div class="line">  [types.REMOVE_FROM_ARR] (state, arr, itemToRemove) &#123;</div><div class="line">    ...</div><div class="line">  &#125;,</div><div class="line">  [types.ADD_TO_ARR] (state, arr, itemToAdd) &#123;</div><div class="line">    ...</div><div class="line">  &#125;,</div><div class="line">  [types.DEL_SCENE] (state, index) &#123;</div><div class="line">    ...</div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> mutations</div></pre></td></tr></table></figure>
<p>具体业务逻辑这里不展开，mutations 中主要就是定义各种对 state 的状态修改。每个 mutation 函数接收<strong>第一个参数为 state 对象</strong>，其余参数则为一路从组件中触发 action 时传过来的 payload。所有的 mutation 函数必须为<strong>同步</strong>执行，否则无法追踪状态的改动。</p>
<p>注意到，这里引入了 mutation-types.js。该文件主要作用为放置所有的命名 Mutations 的常量，方便合作开发人员厘清整个 app 包含的 mutations。在采用模块机制时，可以在每个模块内只引入相关的 mutations，也可以像本项目一样使用 <code>import * as types</code> 简单粗暴地引入全部。</p>
<p>mutation-types.js 中内容大致如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> CHANGE_LAYER_ZINDEX = <span class="string">'CHANGE_LAYER_ZINDEX'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> DEL_LAYER = <span class="string">'DEL_LAYER'</span></div></pre></td></tr></table></figure>
<p>然后我们来到 <strong>actions</strong>，照例先看一下 vuex/editor/actions/index.js 中的内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> types <span class="keyword">from</span> <span class="string">'../mutation-types'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">delLayer</span>(<span class="params"> &#123; dispatch &#125;, index</span>) </span>&#123;</div><div class="line">  dispatch(types.DEL_LAYER, index)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">delScene</span>(<span class="params"> &#123; dispatch &#125;, index</span>) </span>&#123;</div><div class="line">  dispatch(types.DEL_SCENE, index)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">removeFromArr</span>(<span class="params"> &#123; dispatch &#125;, arr, itemToRemove</span>) </span>&#123;</div><div class="line">  dispatch(types.REMOVE_FROM_ARR, arr, itemToRemove)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addToArr</span>(<span class="params"> &#123; dispatch &#125;, arr, itemToAdd</span>) </span>&#123;</div><div class="line">  dispatch(types.ADD_TO_ARR, arr, itemToAdd)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>actions 的主要工作就是 <strong>dispatch</strong> （中文译为分发）mutations。初入门的同学可能觉得这是<strong>多此一举</strong>，actions 这一步看起来完全可以省略。</p>
<p>事实上，actions 的出现是为了弥补 mutations 无法实现异步操作的缺陷。所有的异步操作都可以放在 actions 中，比如如果想在调用 delScene 函数 5 秒后再分发 mutations，可以写成这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">delScene</span> (<span class="params">&#123; dispatch &#125;, index</span>) </span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    dispatch(types.DEL_SCENE, index)</div><div class="line">  &#125;, <span class="number">5000</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>触发 mutations 的代码不会在组件中出现，<strong>但 actions 会出现在每个需要它的组件中</strong>，其也是连接组件和 mutations 的桥梁（额，另一条桥梁是 state，见上面那张经典老图）。在子组件中引入 actions 的方式类似 state，也是注册在 vuex 选项下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// src/components/h5/Navbar.vue</span></div><div class="line">...</div><div class="line"></div><div class="line">import &#123; </div><div class="line">  undoAction, </div><div class="line">  redoAction,</div><div class="line">  togglePreviewStatus,</div><div class="line">  ...</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'vuex/editor/actions'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    data () &#123;</div><div class="line">      <span class="keyword">return</span> &#123;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">methods</span>: &#123;</div><div class="line">      ...</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">vuex</span>: &#123;</div><div class="line">      <span class="attr">actions</span>: &#123;</div><div class="line">        undoAction,</div><div class="line">        redoAction,</div><div class="line">        togglePreviewStatus,</div><div class="line">        ...</div><div class="line">      &#125;,</div><div class="line">      <span class="attr">getters</span>: &#123;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，组件中可以直接调用各个 actions，比如 <code>this.togglePreviewStatus(status)</code>，等价于<code>this.togglePreviewStatus( this.$store, status)</code>（还记得我们在 actions 中定义的各个函数的第一个参数是 store 吗？）。这是最基本的使用 actions 的方式，在此基础上你还可以玩出别的花样来，比如给 actions 取别名、定义内联 actions、绑定所有 actions 等，具体用法参见官方文档。</p>
<p>回过头去看 vuex 文件夹下的目录结构，发现还有一个 plugins 我们没有介绍。老规矩，先看一下  vuex/editor/plugins/index.js 中的内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">export <span class="function"><span class="keyword">function</span> <span class="title">actionLogPlugin</span>(<span class="params">store</span>) </span>&#123;</div><div class="line"></div><div class="line">  store.subscribe(<span class="function">(<span class="params">mutation, state</span>) =&gt;</span> &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 每次 mutation 之后调用</span></div><div class="line">    <span class="comment">// mutation 的格式为 &#123; type, payload &#125;</span></div><div class="line">    ...</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>核心部分在于采用 <code>store.subscribe</code> 注册了一个函数。</p>
<blockquote>
<p>该函数会在每次 mutation 之后被调用。这里 actionLogPlugin 函数完成的是记录每次 mutation 操作，实现撤销重做功能。具体实现逻辑此处不作赘述。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vuex 作为中大型 Vue 应用中的“御用”集中数据管理工具，在实习时的公司很早就得到了广泛使用。本文旨在以尽可能简洁的文字向读者展示：如何在一个颇具规模的 Vue 应用中&lt;strong&gt;组织和管理 Vuex 的代码&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;

    
    </summary>
    
      <category term="技术使用" scheme="http://chriscindy.top/categories/%E6%8A%80%E6%9C%AF%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="Vue.js" scheme="http://chriscindy.top/tags/Vue-js/"/>
    
      <category term="Vuex" scheme="http://chriscindy.top/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>[译][草案] HTTP “带外”内容编码</title>
    <link href="http://chriscindy.top/post/%5Btranslation%5D-Out-Of-Band-Content-Coding/"/>
    <id>http://chriscindy.top/post/[translation]-Out-Of-Band-Content-Coding/</id>
    <published>2016-12-18T09:48:12.000Z</published>
    <updated>2017-04-21T08:41:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>前言</p>
<p>这篇译文其实是高级计网课的作业，教授要求在 <a href="ietf.org">IETF</a> 上找一篇尚未成为 RFC、也就是还处于草案状态的文档翻译一下。于是笔者随便搜了篇 HTTP 协议相关的文档。翻译完毕后感觉还是有一些收获的。这篇文档主要描述了一种新的内容编码格式——out-of-band（文中译为带外，但是我很不喜欢这个翻译，如有更合适的译词欢迎指正），用于描述包含客户端请求资源的辅助服务器的地址。此举可帮助源服务器建立“盲缓存”机制，将内容的传递安全地委派给辅助服务器，该辅助服务器可能在网络拓扑层次上来说“更接近”客户端。感兴趣的同学可以继续往下查看。</p>
<p>Network Working Group<br>Internet-Draft<br>Intended status: Standards Track<br>Expires: May 3, 2017<br>October 30, 2016</p>
<p>J. Reschke   greenbytes  S. Loreto  Ericsson</p>
</blockquote>
<h1 id="“带外”-HTTP-内容编码"><a href="#“带外”-HTTP-内容编码" class="headerlink" title="“带外” HTTP 内容编码"></a>“带外” HTTP 内容编码</h1><h1 id="draft-reschke-http-oob-encoding-09"><a href="#draft-reschke-http-oob-encoding-09" class="headerlink" title="draft-reschke-http-oob-encoding-09"></a>draft-reschke-http-oob-encoding-09</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文档描述了一种超文本传输协议（HTTP）的内容编码，其可用于描述包含有效负载的辅助资源的位置。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4</div><div class="line">2.  Notational Conventions . . . . . . . . . . . . . . . . . . . .  4</div><div class="line">3.  &apos;Out-Of-Band&apos; Content Coding . . . . . . . . . . . . . . . . .  4</div><div class="line">     3.1.  Overview . . . . . . . . . . . . . . . . . . . . . . . . .  4</div><div class="line">     3.2.  Definitions  . . . . . . . . . . . . . . . . . . . . . . .  5</div><div class="line">     3.3.  Processing Steps . . . . . . . . . . . . . . . . . . . . .  6</div><div class="line">     3.4.  Examples . . . . . . . . . . . . . . . . . . . . . . . . .  7</div><div class="line">      3.4.1.  Basic Example  . . . . . . . . . . . . . . . . . . . .  7</div><div class="line">      3.4.2.  Example for an attempt to use &apos;out-of-band&apos; cross-origin . . . . . . . . . . . .  9</div><div class="line">      3.4.3.  Example involving an encrypted resource  . . . . . . .  9</div><div class="line">      3.4.4.  Relation to Content Negotiation  . . . . . . . . . . . 11</div><div class="line">4.  Content Codings and Range Requests . . . . . . . . . . . . . . 12</div><div class="line">5.  Feature Discovery  . . . . . . . . . . . . . . . . . . . . . . 12</div><div class="line">6.  Security Considerations  . . . . . . . . . . . . . . . . . . . 13</div><div class="line">     6.1.  Content Modifications  . . . . . . . . . . . . . . . . . . 13</div><div class="line">     6.2.  Content Stealing . . . . . . . . . . . . . . . . . . . . . 13</div><div class="line">     6.3.  Use in Requests  . . . . . . . . . . . . . . . . . . . . . 13</div><div class="line">7.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 13</div><div class="line">     7.1.  Content Coding: out-of-band  . . . . . . . . . . . . . . . 14</div><div class="line">     7.2.  Internet Media Type: application/oob-stream  . . . . . . . 14</div><div class="line">8.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 15</div><div class="line">     8.1.  Normative References . . . . . . . . . . . . . . . . . . . 15</div><div class="line">     8.2.  Informative References . . . . . . . . . . . . . . . . . . 16</div><div class="line">Appendix A.  Problem Reporting . . . . . . . . . . . . . . . . . . 17</div><div class="line">    A.1.  Server Not Reachable . . . . . . . . . . . . . . . . . . . 18</div><div class="line">    A.2.  Resource Not Found . . . . . . . . . . . . . . . . . . . . 18</div><div class="line">    A.3.  Payload Unusable . . . . . . . . . . . . . . . . . . . . . 18</div><div class="line">    A.4.  TLS Handshake Failure  . . . . . . . . . . . . . . . . . . 18</div><div class="line">    A.5.  Example For Problem Reporting  . . . . . . . . . . . . . . 18</div><div class="line">Appendix B.  Alternatives, or: why not a new Status Code?  . . . . 19</div><div class="line">Appendix C.  Open Issues . . . . . . . . . . . . . . . . . . . . . 19</div><div class="line">    C.1.  Accessing the Secondary Resource Too Early . . . . . . . . 19</div><div class="line">    C.2.  Resource maps  . . . . . . . . . . . . . . . . . . . . . . 20</div><div class="line">    C.3.  Fragmenting  . . . . . . . . . . . . . . . . . . . . . . . 20</div><div class="line">    C.4.  Relation to Content Encryption . . . . . . . . . . . . . . 21</div><div class="line">    C.5.  Reporting  . . . . . . . . . . . . . . . . . . . . . . . . 21</div><div class="line">    C.6.  Controlling Transmission Of Various Request Header Fields . . . . . . . .  . . . . . 21</div><div class="line">Appendix D.  Change Log (to be removed by RFC Editor before publication)  . . . . . . . .  . . 22</div><div class="line">    D.1.  Changes since draft-reschke-http-oob-encoding-00 . . . . . 22</div><div class="line">    D.2.  Changes since draft-reschke-http-oob-encoding-01 . . . . . 22</div><div class="line">    D.3.  Changes since draft-reschke-http-oob-encoding-02 . . . . . 22</div><div class="line">    D.4.  Changes since draft-reschke-http-oob-encoding-03 . . . . . 22</div><div class="line">    D.5.  Changes since draft-reschke-http-oob-encoding-04 . . . . . 22</div><div class="line">    D.6.  Changes since draft-reschke-http-oob-encoding-05 . . . . . 23</div><div class="line">    D.7.  Changes since draft-reschke-http-oob-encoding-06 . . . . . 23</div><div class="line">    D.8.  Changes since draft-reschke-http-oob-encoding-07 . . . . . 23</div><div class="line">    D.9.  Changes since draft-reschke-http-oob-encoding-08 . . . . . 23</div><div class="line">Appendix E.  Acknowledgements  . . . . . . . . . . . . . . . . . . 24</div></pre></td></tr></table></figure>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>本文档描述了超文本传输协议（HTTP）的内容编码（[RFC7231] 的第 3.1.2.1 节），其可用于描述包含有效负载辅助资源的位置。</p>
<p>此内容编码的主要用例是使得源服务器将内容的传递安全地委派给辅助服务器，该服务器可能“更接近”客户端（相对于网络拓扑上来说）和/或能够缓存内容（[SCD]）并加密内容（[ENCRYPTENC]）。</p>
<h2 id="2-符号约定"><a href="#2-符号约定" class="headerlink" title="2. 符号约定"></a>2. 符号约定</h2><p>该文档中的关键词“MUST”，“MUST NOT”，“REQUIRED”，“SHALL”，“SHALL NOT”，“SHOULD”，“SHOULD NOT”，“RECOMMENDED”，“MAY”和“OPTIONAL”应按 [RFC2119] 中所述进行解释。</p>
<p>本文重用基本 HTTP 规范，即 [RFC7230] 的第 2 节和 [RFC7231] 中的第 3 节中使用的术语。</p>
<h2 id="3-“带外”内容编码"><a href="#3-“带外”内容编码" class="headerlink" title="3.  “带外”内容编码"></a>3.  “带外”内容编码</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>带外内容编码用于指导接收者从一个辅助资源比如公共缓存处检索实际的消息表示（参见[RFC7231] 的第 3 节）</p>
<ol>
<li>客户端发送一个请求</li>
<li>接收到的响应指定“带外”内容编码；该响应的负载包含了额外的元数据，以及辅助资源的位置信息</li>
<li>客户端向辅助资源发送 GET 请求（通常也是通过 HTTP(s)）</li>
<li>辅助服务器提供有效负载资源</li>
<li>客户端将以上的表示和从主要资源处获得的表示元数据结合起来</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">客户端                   辅助服务器                   源服务器</div><div class="line"></div><div class="line">    发送带有 Accept-Encoding: out-of-band 头的 GET 请求</div><div class="line">(1) |---------------------------------------------------------\</div><div class="line">                  状态码 200 以及返回头 Content-Coding: out-of-band |</div><div class="line">(2) &lt;---------------------------------------------------------/</div><div class="line"></div><div class="line">    向辅助服务器发送 GET 请求</div><div class="line">(3) |---------------------------\</div><div class="line">                       有效负载 |</div><div class="line">(4) &lt;---------------------------/</div><div class="line"></div><div class="line">(5)</div><div class="line">    客户端将第（4）步接收到的 有效负载和第（2）步接收到的元数据结合起来。</div></pre></td></tr></table></figure>
<h3 id="3-2-定义"><a href="#3-2-定义" class="headerlink" title="3.2 定义"></a>3.2 定义</h3><p>该内容编码的名称为“带外”。</p>
<p>有效负载格式为 JavaScript 对象标记（即 JSON，参见 [RFC7159]）,用于描述一个描述辅助资源信息的对象；目前仅仅定义了一个成员：</p>
<p>“sr”：一个必需的 JSON 对象数组。每个对象包括一个名为“r”的成员，该成员用于描述一个辅助资源的信息，其值为包含一个对该辅助资源的 URI 引用（参见 [RFC3986]的 4.1 小节）的字符串（作为相对引用的 URI 引用会根据主资源的 URI 来解析）。</p>
<p>有效负载格式使用数组以保证源服务器可以指定多个辅助资源地址。数组的排序反映了源服务器对待辅助资源的优先级（如果存在的话）。优先级最高的辅助资源位置将排在第一位。客户端在接收到包含多个辅助资源位置的响应时可以自由选择使用哪一个辅助资源。</p>
<p>在某些情况下，源服务器可能想指定一个“回退 URI”；标识一个由源服务器自身提供的辅助资源，但是除此以外和其他“常规”辅助资源完全相等。任何由源服务器作为主机的辅助资源都可以作为一个“回退”；源服务器通常将这些辅助资源列在“sr”数组的最后，以使它们只有在没有其他选择时才会被客户端使用。</p>
<p>新的规范可以定义新的可选成员字段，因此客户端必须忽略未知字段。此外，新的规范还可以为“sr”数组定义新的对象格式；但是，除非语义上与以上定义的部分相兼容，否则新规范不得使用名为“r”的成员。</p>
<p>扩展的规范必须更新此规范。</p>
<h3 id="3-3-处理步骤"><a href="#3-3-处理步骤" class="headerlink" title="3.3 处理步骤"></a>3.3 处理步骤</h3><p>在接收到一个“带外”编码的响应时，客户端首先需要获得辅助资源的呈现。这是使用 HTTP 的 GET 请求实现的（独立于原始请求方法）。</p>
<p>为了防止任何信息泄漏，对辅助资源的 GET 请求必须只包含由源服务器或者辅助服务器自身提供的信息，即 HTTP 认证凭证（[RFC7235]）和 cookie（[RFC6265]）。</p>
<p>此外，该请求必须包括“Origin”报头字段，用于指示原始资源的来源（参见 [RFC6454]的第 7 节）。 辅助服务器必须验证该特定源是经过授权的，才可以检索给定的有效载荷（或以其他方式返回适当的 4xx 状态码）。</p>
<p>除此之外，辅助服务器的响应必须包括一个“Content-Type”报头字段，用于指定一种叫做“application / oob-stream”的互连网媒体类型。 客户端必须校验此媒体类型。如果未指定媒体类型，或其并不匹配此值，则中止带外处理。</p>
<p>在接收到辅助资源的有效负载后，客户端通过以下方式重构原始消息：</p>
<ol>
<li>通过去除所有传输和内容编码来解封装 HTTP 消息</li>
<li>替换/设置来自主响应的所有响应头字段，除了 Content-Length，Transfer-Encoding 以及 Content-Encoding 等帧相关的信息。</li>
</ol>
<p>如果客户端无法检索辅助资源（无法访问主机，非 2xx 响应状态代码，有效载荷完整性校验失败等），它可以选择替代的辅助资源（如果有指定），尝试回退 URI（如果给定），或者简单地重新向源服务器发起请求，但在 Accept-Encoding 请求头字段中不包含 “out-of-band”。在后一种情况下，将请求辅助资源时遇到的问题通知到源服务器是有用的。详情见附录A。<br>​<br>注意，尽管这种机制导致引入了外部内容，但是它不会影响重构消息的应用程序级的安全属性，比如它的 web 源（[RFC6454]）。</p>
<p>辅助资源的响应的缓存能力不会影响重构的响应消息的缓存能力，重构的响应消息的缓存能力与与原始服务器的响应相同。</p>
<p>“带外”编码的使用在某些方面类似于 HTTP 重定向（参见 [RFC7231] 第 6.4 节），比如它可能导致循环。除非遇到 HTTP 重定向，否则客户端是完全处于控制的：它不需要在向辅助资源的请求中宣称支持“带外”编码。或者，它可以像在 HTTP 重定向情况下一样保护自己——通过限制其支持的间接寻址的数量。</p>
<p>注意，因为服务器的响应取决于请求的 Accept-Encoding 头字段，响应通常需要宣告其上的变化。详情参见 [RFC7231] 的 7.1.4 节和 [RFC7232] 的 2.3 节。</p>
<h3 id="3-4-示例"><a href="#3-4-示例" class="headerlink" title="3.4 示例"></a>3.4 示例</h3><h4 id="3-4-1-基本示例"><a href="#3-4-1-基本示例" class="headerlink" title="3.4.1 基本示例"></a>3.4.1 基本示例</h4><p>客户端向位于 <a href="https://www.example.com/test" target="_blank" rel="external">https://www.example.com/test</a> 的主资源发送请求：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GET</span> <span class="string">/test</span> HTTP/1.1</div><div class="line"><span class="attribute">Host</span>: www.example.com</div><div class="line"><span class="attribute">Accept-Encoding</span>: gzip, out-of-band</div></pre></td></tr></table></figure>
<p>响应：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Date: Thu, 14 May 2015 18:52:00 GMT</div><div class="line">Content-Type: text/plain</div><div class="line">Cache-Control: max-age=10, public</div><div class="line">Content-Encoding: out-of-band</div><div class="line">Content-Length: 165</div><div class="line">Vary: Accept-Encoding</div><div class="line">    </div><div class="line">&#123;</div><div class="line">  "sr": [</div><div class="line">    &#123; "r" :</div><div class="line">      "http://example.net/bae27c36-fa6a-11e4-ae5d-00059a3c7a00"&#125;,</div><div class="line">    &#123; "r" :</div><div class="line">       "/c/bae27c36-fa6a-11e4-ae5d-00059a3c7a00"&#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（注意到 Content-Type 头字段描述了辅助资源的媒体类型，同时源服务器提供了回退 URI）</p>
<p>客户端向辅助资源发送请求：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GET</span> <span class="string">/bae27c36-fa6a-11e4-ae5d-00059a3c7a00</span> HTTP/1.1</div><div class="line"><span class="attribute">Host</span>: example.net</div><div class="line"><span class="attribute">Origin</span>: https://www.example.com</div></pre></td></tr></table></figure>
<p>响应:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Date: Thu, 14 May 2015 18:52:10 GMT</div><div class="line">Cache-Control: private</div><div class="line">Content-Type: application/oob-stream</div><div class="line">Content-Length: 15</div><div class="line">    </div><div class="line">Hello, world.</div></pre></td></tr></table></figure>
<p>在重组头字段后，最终的消息如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Date: Thu, 14 May 2015 18:52:00 GMT</div><div class="line">Content-Length: 15</div><div class="line">Cache-Control: max-age=10, public</div><div class="line">Content-Type: text/plain</div><div class="line">    </div><div class="line">Hello, world.</div></pre></td></tr></table></figure>
<h4 id="3-4-2-尝试跨域使用“带外”的示例"><a href="#3-4-2-尝试跨域使用“带外”的示例" class="headerlink" title="3.4.2 尝试跨域使用“带外”的示例"></a>3.4.2 尝试跨域使用“带外”的示例</h4><p>3.3 小节需要客户端在向辅助服务器发送的请求中包含一个“Origin”头字段。下面的例子展示了用于处理辅助资源的服务器将如何响应一个包含了“Origin”头字段的请求，同时该头字段标识了一个未经授权的源。</p>
<p>继续 3.4.1 小节中的例子，一个辅助服务器已被配置，其能够允许由“<a href="https://www.example.org”启动的请求：" target="_blank" rel="external">https://www.example.org”启动的请求：</a><br>​<br>客户端向辅助服务器发起的请求：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GET</span> <span class="string">/bae27c36-fa6a-11e4-ae5d-00059a3c7a00</span> HTTP/1.1</div><div class="line"><span class="attribute">Host</span>: example.net</div><div class="line"><span class="attribute">Origin</span>: https://www.example.com</div></pre></td></tr></table></figure>
<p>响应：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 <span class="number">403</span> Forbidden</div><div class="line"><span class="attribute">Date</span>: Thu, 14 May 2015 18:52:10 GMT</div></pre></td></tr></table></figure>
<p>注意，缺少“Origin”头字段的请求将获得同以上请求一样的对待。</p>
<h4 id="3-4-3-含有加密资源的示例"><a href="#3-4-3-含有加密资源的示例" class="headerlink" title="3.4.3 含有加密资源的示例"></a>3.4.3 含有加密资源的示例</h4><p>给定来自 [ENCRYPTENC] 5.1 小节的示例 HTTP 消息，主要资源可以使用“带外”编码来指定辅助资源的位置以及解密有效载荷所需的“Crypto-Key”报头字段的内容：</p>
<p>响应：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Date: Thu, 14 May 2015 18:52:00 GMT</div><div class="line">Content-Encoding: aesgcm, out-of-band</div><div class="line">Content-Type: text/plain</div><div class="line">Encryption: keyid="a1"; salt="vr0o6Uq3w_KDWeatc27mUg"</div><div class="line">Crypto-Key: keyid="a1"; aesgcm="csPJEXBYA5U-Tal9EdJi-w"</div><div class="line">Content-Length: 101</div><div class="line">Vary: Accept-Encoding</div><div class="line">    </div><div class="line">&#123;</div><div class="line">  "sr": [</div><div class="line">    &#123; "r" :</div><div class="line">      "http://example.net/bae27c36-fa6a-11e4-ae5d-00059a3c7a00"&#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（注意，Content-Type 头字段描述了辅助资源的表现形式）<br>辅助资源的响应：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Date: Thu, 14 May 2015 18:52:10 GMT</div><div class="line">Content-Type: application/oob-stream</div><div class="line">Content-Length: ...</div><div class="line">    </div><div class="line">VDeU0XxaJkOJDAxPl7h9JD5V8N43RorP7PfpPdZZQuwF</div><div class="line">（这里负载体以 base64 的编码格式显示）</div></pre></td></tr></table></figure>
<p>解开所有内容编码后的最终消息形式为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Date: Thu, 14 May 2015 18:52:00 GMT</div><div class="line">Content-Length: 15</div><div class="line">Content-Type: text/plain</div><div class="line">    </div><div class="line">I am the walrus</div></pre></td></tr></table></figure>
<p>注意：在这种情况下，解码“aesgcm”需要先处理响应。如果在请求中“aesgcm”没有被列为可接受的内容编码，源服务器将不能使用“带外”机制。</p>
<p>“带外”编码的使用是“积极内容协商”的一个实例，该概念在 [RFC7231] 的 3.4 小节被定义。</p>
<p>然而，这并不排除将其与其他内容组合编码。 举个例子，与“gzip”内容编码（参见 [RFC7230] 的第 4.2.3 节）可能组合的情形被描述如下：</p>
<ul>
<li><p>实例1： 主资源不支持“gzip”编码<br>在这种情况下，主资源的响应将永远不会在 Content-Encoding 头字段中包含“gzip”。但是辅助资源可能支持它，在这种情况下客户端可以通过在向辅助资源的请求中包含“Accept-Encoding：gzip”来协商压缩。</p>
</li>
<li><p>实例2：主资源支持“gzip”编码<br>这里，原始服务器实际上将使用两个不同的辅助资源，其中之一是经过 gzip 压缩的。 例如——回到 3.4.1 节的第一个例子——它可能回复如下：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 <span class="number">200</span> OK</div><div class="line"><span class="attribute">Date</span>: Thu, 14 May 2015 18:52:00 GMT</div><div class="line"><span class="attribute">Content-Type</span>: text/plain</div><div class="line"><span class="attribute">Cache-Control</span>: max-age=10, public</div><div class="line"><span class="attribute">Content-Encoding</span>: gzip, out-of-band</div><div class="line"><span class="attribute">Content-Length</span>: 165</div><div class="line"><span class="attribute">Vary</span>: Accept-Encoding</div><div class="line"></div><div class="line"><span class="json">&#123;</span></div><div class="line">  <span class="attr">"sr"</span>: [</div><div class="line">    &#123; <span class="attr">"r"</span> :</div><div class="line">      <span class="string">"http://example.net/bae27c36-fa6a-11e4-ae5d-00059a3c7a01"</span>&#125;,</div><div class="line">    &#123; <span class="attr">"r"</span> :</div><div class="line">      <span class="string">"/c/bae27c36-fa6a-11e4-ae5d-00059a3c7a01"</span>&#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这意味着辅助资源的有效负载已经经过 gzip 压缩。</p>
</li>
</ul>
<p>注意：原始服务器也可以将 gzip 压缩应用于带外有效载荷，在这种情况下内容编码字段的值将变为：“gzip，out-of-band，gzip”。</p>
<h2 id="4-内容编码和范围请求"><a href="#4-内容编码和范围请求" class="headerlink" title="4. 内容编码和范围请求"></a>4. 内容编码和范围请求</h2><p>内容编码的组合（参见 [RFC7231] 的第 3.1.2 节与范围请求（[RFC7233]）可以导致令人惊讶的结果，因为应用范围请求在应用内容编码之后发生。</p>
<p>因此，对于从位置 100000 字节处开始的视频的请求：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GET</span> <span class="string">/test.mp4</span> HTTP/1.1</div><div class="line"><span class="attribute">Host</span>: www.example.com</div><div class="line"><span class="attribute">Range</span>: bytes=100000-</div><div class="line"><span class="attribute">Accept-Encoding</span>: identity</div></pre></td></tr></table></figure>
<p>……成功的响应将使用 206 状态码（部分内容），并且包含一个内容为从位置 100000 开始的八位字节的有效负载。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 <span class="number">206</span> Partial Content</div><div class="line"><span class="attribute">Date</span>: Thu, 08 September 2015 16:49:00 GMT</div><div class="line"><span class="attribute">Content-Type</span>: video/mp4</div><div class="line"><span class="attribute">Content-Length</span>: 134567</div><div class="line"><span class="attribute">Content-Range</span>: bytes 100000-234566/234567</div><div class="line"></div><div class="line"><span class="undefined">(二进制数据)</span></div></pre></td></tr></table></figure>
<p>但是，如果请求允许使用“带外”编码：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GET</span> <span class="string">/test.mp4</span> HTTP/1.1</div><div class="line"><span class="attribute">Host</span>: www.example.com</div><div class="line"><span class="attribute">Range</span>: bytes=100000-</div><div class="line"><span class="attribute">Accept-Encoding</span>: out-of-band</div></pre></td></tr></table></figure>
<p>……服务器可能会返回一个空的负载（如果经过带外编码的响应体小于 100000 字节，而通常情况下就是这样的）。</p>
<p>因此，为了避免不必要的网络流量，服务器“不应该”将范围请求处理应用于使用带外内容编码的响应（或者，换句话说，忽略“Range”请求头字段）。</p>
<h2 id="5-功能探索"><a href="#5-功能探索" class="headerlink" title="5. 功能探索"></a>5. 功能探索</h2><p>新的内容编码很容易进行部署，因为客户端可以使用“Accept-Encoding”头字段（参见 [RFC7231]的 5.3.4 小节）来标记其支持哪些内容编码。</p>
<h2 id="6-安全事项"><a href="#6-安全事项" class="headerlink" title="6. 安全事项"></a>6. 安全事项</h2><h3 id="6-1-内容修改"><a href="#6-1-内容修改" class="headerlink" title="6.1 内容修改"></a>6.1 内容修改</h3><p>本规范没有定义如何验证从辅助资源处获得的有效负载是否确实是源服务器期望获得的。不过内容签名可以解决这个问题（见[CONTENTSIG]和[MICE]）。</p>
<h3 id="6-2-内容窃取"><a href="#6-2-内容窃取" class="headerlink" title="6.2 内容窃取"></a>6.2 内容窃取</h3><p>“带外”内容编码可以用于规避用户代理的同源原则策略（参见 [RFC6454] 第 3 节）：知道辅助资源的 URI 攻击站点将使用“带外”编码来欺骗用户代理读取辅助资源的内容，然后，由于这种编码的安全属性，这种欺骗行为将被识别成好像其产生于源地址。</p>
<p>这种情况可以这样处理：客户端要求包括“Origin”头字段，同时服务端需要验证收到的请求是由经过验证的源发送的。此外，辅助服务器的响应的媒体类型对“application / oob-stream”的限制能够保护未实现此规范的“正常”服务器上的现有内容。</p>
<p>注：与“跨源资源共享”协议（[CORS]）的相似是有意为之的。<br>对辅助资源的有效内容进行加密（[ENCRYPTENC]）是一个额外的有效措施。</p>
<h3 id="6-3-在请求中的使用"><a href="#6-3-在请求中的使用" class="headerlink" title="6.3 在请求中的使用"></a>6.3 在请求中的使用</h3><p>一般来说，内容编码可以用于请求和响应。 这个特定的内容编码已经被设计用于响应。 当请求中也支持时，它会创建一个新的攻击方向，接收服务器可以被欺骗，然后返回客户端可能原本无法访问的内容（例如由防火墙保护的 HTTP 资源）。</p>
<h2 id="7-IANA-注意事项"><a href="#7-IANA-注意事项" class="headerlink" title="7. IANA 注意事项"></a>7. IANA 注意事项</h2><h3 id="7-1-Content-Coding-out-of-band"><a href="#7-1-Content-Coding-out-of-band" class="headerlink" title="7.1 Content Coding: out-of-band"></a>7.1 Content Coding: out-of-band</h3><p>网址为<a href="http://www.iana.org/assignments/http-parameters" target="_blank" rel="external">http://www.iana.org/assignments/http-parameters</a>的 IANA（互联网号码分配局） 的“HTTP 内容编码注册”需要用以下的注册内容来更新：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Name:  out-of-band</div><div class="line">Description:  Payload needs to be retrieved from a secondary resource</div><div class="line">Reference:  Section 3 of this document</div></pre></td></tr></table></figure>
<h3 id="7-2-Internet-Media-Type-application-oob-stream"><a href="#7-2-Internet-Media-Type-application-oob-stream" class="headerlink" title="7.2 Internet Media Type: application/oob-stream"></a>7.2 Internet Media Type: application/oob-stream</h3><p>IANA 在<a href="http://www.iana.org/assignments/media-types" target="_blank" rel="external">http://www.iana.org/assignments/media-types</a>上维护互联网媒体类型 [BCP13] 的注册。</p>
<p>此文档用作互联网媒体类型“application / oob-stream” 的规范。 以下是在 IANA 要注册的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Type name:  application</div><div class="line">Subtype name:  oob-stream</div><div class="line">Required parameters:  N/A</div><div class="line">Optional parameters:  N/A</div><div class="line">Encoding considerations:  always &quot;binary&quot;</div><div class="line">Security considerations:  see Section 6</div><div class="line">Interoperability considerations:  N/A</div><div class="line">Published specification:  This specification (see Section 7.2).</div><div class="line">Applications that use this media type:  HTTP servers for secondary</div><div class="line">  resources as defined by this specification.</div><div class="line">Fragment identifier considerations:  N/A</div><div class="line">Additional information:</div><div class="line">  Magic number(s):  N/A</div><div class="line">  Deprecated alias names for this type:  N/A</div><div class="line">  File extension(s):  N/A</div><div class="line">  Macintosh file type code(s):  N/A</div><div class="line">Person and email address to contact for further information:  See</div><div class="line">  Authors&apos; Addresses section.</div><div class="line">Intended usage:  COMMON</div><div class="line">Restrictions on usage:  N/A</div><div class="line">Author:  See Authors&apos; Addresses section.</div><div class="line">Change controller:  IESG</div></pre></td></tr></table></figure>
<h2 id="8-参考文献"><a href="#8-参考文献" class="headerlink" title="8. 参考文献"></a>8. 参考文献</h2><h3 id="8-1-规范性引用文件"><a href="#8-1-规范性引用文件" class="headerlink" title="8.1 规范性引用文件"></a>8.1 规范性引用文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line">[RFC2119]     </div><div class="line">Bradner, S., &quot;Key words for use in RFCs to Indicate</div><div class="line">Requirement Levels&quot;, BCP 14, RFC 2119, DOI 10.17487/</div><div class="line">RFC2119, March 1997,</div><div class="line">&lt;http://www.rfc-editor.org/info/rfc2119&gt;.</div><div class="line"></div><div class="line">[RFC3986]     </div><div class="line">Berners-Lee, T., Fielding, R., and L. Masinter,</div><div class="line">&quot;Uniform Resource Identifier (URI): Generic Syntax&quot;,</div><div class="line">STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005,</div><div class="line">&lt;http://www.rfc-editor.org/info/rfc3986&gt;.</div><div class="line"></div><div class="line">[RFC5988]     </div><div class="line">Nottingham, M., &quot;Web Linking&quot;, RFC 5988, DOI 10.17487/</div><div class="line">RFC5988, October 2010,</div><div class="line">&lt;http://www.rfc-editor.org/info/rfc5988&gt;.</div><div class="line"></div><div class="line">[RFC6265]     </div><div class="line">Barth, A., &quot;HTTP State Management Mechanism&quot;, RFC 6265,</div><div class="line">DOI 10.17487/RFC6265, April 2011,</div><div class="line">&lt;http://www.rfc-editor.org/info/rfc6265&gt;.</div><div class="line"></div><div class="line">[RFC7159]     </div><div class="line">Bray, T., &quot;The JavaScript Object Notation (JSON) Data</div><div class="line">Interchange Format&quot;, RFC 7159, DOI 10.17487/RFC7159,</div><div class="line">March 2014, &lt;http://www.rfc-editor.org/info/rfc7159&gt;.</div><div class="line"></div><div class="line">[RFC7230]     </div><div class="line">Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext</div><div class="line">Transfer Protocol (HTTP/1.1): Message Syntax and</div><div class="line">Routing&quot;, RFC 7230, DOI 10.17487/RFC7230, June 2014,</div><div class="line">&lt;http://www.rfc-editor.org/info/rfc7230&gt;.</div><div class="line"></div><div class="line">[RFC7231]     </div><div class="line">Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext</div><div class="line">Transfer Protocol (HTTP/1.1): Semantics and Content&quot;,</div><div class="line">RFC 7231, DOI 10.17487/RFC7231, June 2014,</div><div class="line">&lt;http://www.rfc-editor.org/info/rfc7231&gt;.</div><div class="line"></div><div class="line">[RFC7235]     </div><div class="line">Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext</div><div class="line">Transfer Protocol (HTTP/1.1): Authentication&quot;,</div><div class="line">RFC 7235, DOI 10.17487/RFC7235, June 2014,</div><div class="line">&lt;http://www.rfc-editor.org/info/rfc7235&gt;.</div><div class="line">[BCP13]       </div><div class="line">Freed, N., Klensin, J., and T. Hansen, &quot;Media Type</div><div class="line">Specifications and Registration Procedures&quot;, BCP 13,</div><div class="line">RFC 6838, January 2013,</div><div class="line">&lt;http://www.rfc-editor.org/info/bcp13&gt;.</div><div class="line"></div><div class="line">[CONTENTSIG]  </div><div class="line">Thomson, M., &quot;Content-Signature Header Field for HTTP&quot;,</div><div class="line">draft-thomson-http-content-signature-00 (work in</div><div class="line">progress), July 2015.</div><div class="line"></div><div class="line">[CORS]        </div><div class="line">van Kesteren, A., &quot;Cross-Origin Resource Sharing&quot;, W3C</div><div class="line">Recommendation REC-cors-20140116, January 2014,</div><div class="line">&lt;http://www.w3.org/TR/2014/REC-cors-20140116/&gt;.</div><div class="line">    </div><div class="line">Latest version available at</div><div class="line">&lt;http://www.w3.org/TR/cors/&gt;.</div><div class="line"></div><div class="line">[ENCRYPTENC]  </div><div class="line">Thomson, M., &quot;Encrypted Content-Encoding for HTTP&quot;,</div><div class="line">draft-ietf-httpbis-encryption-encoding-03 (work in</div><div class="line">progress), October 2016.</div><div class="line"></div><div class="line">[MICE]        </div><div class="line">Thomson, M., &quot;Merkle Integrity Content Encoding&quot;,</div><div class="line">draft-thomson-http-mice-02 (work in progress),</div><div class="line">October 2016.</div><div class="line"></div><div class="line">[RFC2017]    </div><div class="line">Freed, N. and K. Moore, &quot;Definition of the URL MIME</div><div class="line">External-Body Access-Type&quot;, RFC 2017, DOI 10.17487/</div><div class="line">RFC2017, October 1996,</div><div class="line">&lt;http://www.rfc-editor.org/info/rfc2017&gt;.</div><div class="line"></div><div class="line">[RFC4483]     </div><div class="line">Burger, E., &quot;A Mechanism for Content Indirection in</div><div class="line">Session Initiation Protocol (SIP) Messages&quot;, RFC 4483,</div><div class="line">DOI 10.17487/RFC4483, May 2006,</div><div class="line">&lt;http://www.rfc-editor.org/info/rfc4483&gt;.</div><div class="line"></div><div class="line">[RFC5246]     </div><div class="line">Dierks, T. and E. Rescorla, &quot;The Transport Layer</div><div class="line">Security (TLS) Protocol Version 1.2&quot;, RFC 5246,</div><div class="line">DOI 10.17487/RFC5246, August 2008,</div><div class="line">&lt;http://www.rfc-editor.org/info/rfc5246&gt;.</div><div class="line"></div><div class="line">[RFC6454]     </div><div class="line">Barth, A., &quot;The Web Origin Concept&quot;, RFC 6454,</div><div class="line">DOI 10.17487/RFC6454, December 2011,</div><div class="line">&lt;http://www.rfc-editor.org/info/rfc6454&gt;.</div><div class="line"></div><div class="line">[RFC7232]     </div><div class="line">Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext</div><div class="line">Transfer Protocol (HTTP/1.1): Conditional Requests&quot;,</div><div class="line">RFC 7232, DOI 10.17487/RFC7232, June 2014,</div><div class="line">&lt;http://www.rfc-editor.org/info/rfc7232&gt;.</div><div class="line"></div><div class="line">[RFC7233]     </div><div class="line">Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed.,</div><div class="line">&quot;Hypertext Transfer Protocol (HTTP/1.1): Range</div><div class="line">Requests&quot;, RFC 7233, DOI 10.17487/RFC7233, June 2014,</div><div class="line">&lt;http://www.rfc-editor.org/info/rfc7233&gt;.</div><div class="line"></div><div class="line">[SCD]        </div><div class="line">Thomson, M., Eriksson, G., and C. Holmberg, &quot;An</div><div class="line">Architecture for Secure Content Delegation using HTTP&quot;,</div><div class="line">draft-thomson-http-scd-02 (work in progress),</div><div class="line">October 2016.</div><div class="line"></div><div class="line">URIs</div><div class="line">[1]  &lt;mailto:ietf-http-wg@w3.org&gt;</div><div class="line"></div><div class="line">[2]  &lt;mailto:ietf-http-wg-request@w3.org?subject=subscribe&gt;</div></pre></td></tr></table></figure>
<h2 id="附录-A-问题报告"><a href="#附录-A-问题报告" class="headerlink" title="附录 A. 问题报告"></a>附录 A. 问题报告</h2><p>[[erwip：这是一个错误报告机制的粗略建议。它够好吗？ 是否需要它？ 注意，Alt-Svc 没有这样的东西。]]</p>
<p>当客户端无法获取辅助资源时，通知源服务器该状况将是有用的。这可以通过添加一个“Link”报头字段（[RFC5988]）到后续发往源服务器的请求来实现。同时该头字段需要详细说明辅助资源的 URI 和失败原因。</p>
<p>定义以下链路扩展关系：</p>
<p>[[purl：需要注册 PURL（现在由 archive.org，FWIW 托管）]]</p>
<h3 id="A-1-服务器不可达"><a href="#A-1-服务器不可达" class="headerlink" title="A.1 服务器不可达"></a>A.1 服务器不可达</h3><p>当服务器不可达时使用。<br>链接关系：<br><a href="http://purl.org/NET/linkrel/not-reachable" target="_blank" rel="external">http://purl.org/NET/linkrel/not-reachable</a></p>
<h3 id="A-2-资源未发现"><a href="#A-2-资源未发现" class="headerlink" title="A.2 资源未发现"></a>A.2 资源未发现</h3><p>当服务器返回响应，但是目标不可获取时使用。<br>链接关系：<br><a href="http://purl.org/NET/linkrel/resource-not-found" target="_blank" rel="external">http://purl.org/NET/linkrel/resource-not-found</a></p>
<h3 id="A-3-负载无法使用"><a href="#A-3-负载无法使用" class="headerlink" title="A.3 负载无法使用"></a>A.3 负载无法使用</h3><p>当负责可以获取到，但是不可使用（例如，完整性校验失败）时使用。<br>链接关系：<br><a href="http://purl.org/NET/linkrel/payload-unusable" target="_blank" rel="external">http://purl.org/NET/linkrel/payload-unusable</a></p>
<h3 id="A-4-TLS-握手失败"><a href="#A-4-TLS-握手失败" class="headerlink" title="A.4 TLS 握手失败"></a>A.4 TLS 握手失败</h3><p>当 TLS 握手失败时使用（[RFC5246]）。<br>链接关系：<br><a href="http://purl.org/NET/linkrel/tls-handshake-failure" target="_blank" rel="external">http://purl.org/NET/linkrel/tls-handshake-failure</a></p>
<h3 id="A-5-问题报告的示例"><a href="#A-5-问题报告的示例" class="headerlink" title="A.5 问题报告的示例"></a>A.5 问题报告的示例</h3><p>拿 3.4.1 节客户端向主资源发起的请求为例，此时假设尝试获取辅助资源失败。</p>
<p>响应:</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 <span class="number">404</span> Not Found</div><div class="line"><span class="attribute">Date</span>: Thu, 08 September 2015 16:49:00 GMT</div><div class="line"><span class="attribute">Content-Type</span>: text/plain</div><div class="line"><span class="attribute">Content-Length</span>: 20</div><div class="line"></div><div class="line"><span class="undefined">Resource Not Found</span></div></pre></td></tr></table></figure>
<p>客户端重新向源服务器发起请求，请求中包括“Link”头字段，用于报告问题：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GET</span> <span class="string">/test</span> HTTP/1.1</div><div class="line"><span class="attribute">Host</span>: www.example.com</div><div class="line"><span class="attribute">Accept-Encoding</span>: gzip, out-of-band</div><div class="line"><span class="attribute">Link</span>: &lt;http://example.net/bae27c36-fa6a-11e4-ae5d-00059a3c7a00&gt;;rel="http://purl.org/NET/linkrel/resource-not-found"</div></pre></td></tr></table></figure>
<h2 id="附录-B-备选方案，或者：为什么不加一个新的状态码？"><a href="#附录-B-备选方案，或者：为什么不加一个新的状态码？" class="headerlink" title="附录 B. 备选方案，或者：为什么不加一个新的状态码？"></a>附录 B. 备选方案，或者：为什么不加一个新的状态码？</h2><p>一种貌似合理的备选方法是在更高一级上实现这个功能，使用新的重定向状态码（参见 [RFC7231] 的 6.4 节）。然而，这将具有以下几个缺点：</p>
<ul>
<li>服务器需要知道客户端是否能够理解新的状态码；这样一些额外的标记加入该协议将是必不可少的。</li>
<li>在重定向消息中，元数据的表现形式（[RFC7231]的 3.1 节），即“Content-Type”，适用于响应消息，而不适用于重定向到的资源。</li>
<li>使用内容编码的原始保留性质将丢失。</li>
</ul>
<p>另一个选择是在媒体类型级别上使用类似“message/external-body”的某个类型来实现间接获取资源，该方法在 [RFC2017] 上定义并在 [RFC4483] 中被改进，在会话发起协议（SIP）中得到使用。但是这种方法具有与上面提到的状态码方法一样的大部分缺点。</p>
<h2 id="附录-C-开放议题"><a href="#附录-C-开放议题" class="headerlink" title="附录 C. 开放议题"></a>附录 C. 开放议题</h2><h3 id="C-1-过早访问辅助资源"><a href="#C-1-过早访问辅助资源" class="headerlink" title="C.1 过早访问辅助资源"></a>C.1 过早访问辅助资源</h3><p>该协议的一个用例是使得系统可以启用“盲缓存”来提供辅助资源。这些缓存可能在需要时才填充,因此可能出现以下情况：无论填充缓存的机制是什么，当客户端命中该缓存的时候可能填充缓存的操作还没有完成（可能因为竞争条件，或者因为缓存位于一个不允许源服务器推送内容至其上的中间件的后面）。</p>
<p>在这种特殊情况下，如果客户端能够“肩扛”主资源的回退 URI，给予辅助服务器一种可以获得有效载荷本身的方法，这将会是非常有用的。这些信息可以在另一个叫做“Link”的头字段中提供：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GET</span> <span class="string">/bae27c36-fa6a-11e4-ae5d-00059a3c7a00</span> HTTP/1.1</div><div class="line"><span class="attribute">Host</span>: example.net</div><div class="line"><span class="attribute">Link</span>: &lt;http://example.com/c/bae27c36-fa6a-11e4-ae5d-00059a3c7a00&gt;;rel="http://purl.org/NET/linkrel/fallback-resource"</div></pre></td></tr></table></figure>
<p>（继续 3.4.1 节的例子）</p>
<h3 id="C-2-资源映射"><a href="#C-2-资源映射" class="headerlink" title="C.2 资源映射"></a>C.2 资源映射</h3><p>当“带外”编码作为缓存解决方案的一部分时，到源服务器的额外往返可能产生重要的性能问题；特别是当许多小资源需要加载时（例如脚本，图像或视频片段）。在这样的情况下，源服务器提供一个“资源映射”，允许这些被映射的资源跳过到源服务器的往返行程将会非常有用。 发送资源映射的合理方式可以是：</p>
<ul>
<li>作为在“带外”编码 JSON 有效载荷中的扩展，或者</li>
<li>作为由“Link”响应头字段标识的单独资源。</li>
</ul>
<p>本规范没有定义格式，也没有定义机制来传输该映射，但它是一些使用“带外”编码的规范将要做的。</p>
<h3 id="C-3-分段"><a href="#C-3-分段" class="headerlink" title="C.3 分段"></a>C.3 分段</h3><p>将原始资源的有效载荷分割为片段，每个片段映射到不同的辅助资源处将是很有趣的。 这将允许不在单个缓存中存储一个资源的所有有效载荷。因此</p>
<ul>
<li>分配负载，</li>
<li>使用不同的方式来缓存资源的不同部分（例如只分配一个长视频的开始几分钟），或</li>
<li>获取资源的特定部分（类似于字节范围请求），或</li>
<li>隐藏来自辅助服务器的信息。</li>
</ul>
<h3 id="C-4-与内容加密的关系"><a href="#C-4-与内容加密的关系" class="headerlink" title="C.4 与内容加密的关系"></a>C.4 与内容加密的关系</h3><p>现在该规范与[ENCRYPTENC]/[MICE]正交；也就是说，它可以用于诸如软件下载之类的公共内容。 然而，强制加密的缺乏影响了安全考虑。我们需要决定是否需要这种水平的独立性。</p>
<h3 id="C-5-报告"><a href="#C-5-报告" class="headerlink" title="C.5 报告"></a>C.5 报告</h3><p>这个规范已经定义了客户端在访问辅助资源失败时可以报告失败的钩子（参见附录 A）。</p>
<p>但是，如果还有办法报告以下的数据，将是有益的：</p>
<ul>
<li>成功（缓存命中）率，和</li>
<li>到辅助服务器的带宽。</li>
</ul>
<p>这可以通过使用新的服务端点和一个（JSON？）有效载荷格式来实现。</p>
<p>类似地，由辅助服务器使用的报告设施也可能是有用的。</p>
<h3 id="C-6-控制各种请求报头字段的传输"><a href="#C-6-控制各种请求报头字段的传输" class="headerlink" title="C.6 控制各种请求报头字段的传输"></a>C.6 控制各种请求报头字段的传输</h3><p>默认情况下，客户端会将一些请求头字段例如“User-Agent“（或一些新定义的”Client Hints“）包含进他们向辅助服务器发送的请求。如果辅助服务器不执行任何内容协商，那么这些头字段实际上都没有用，所以在默认情况下禁止它们可能是一个减少识别的好主意。在这种情况下，我们可以允许源服务器选择发送它们其中的一部分。</p>
<h2 id="附录-D-修改日志（在发布前将被-RFC-编辑者移除）"><a href="#附录-D-修改日志（在发布前将被-RFC-编辑者移除）" class="headerlink" title="附录 D 修改日志（在发布前将被 RFC 编辑者移除）"></a>附录 D 修改日志（在发布前将被 RFC 编辑者移除）</h2><h3 id="D-1-Changes-since-draft-reschke-http-oob-encoding-00"><a href="#D-1-Changes-since-draft-reschke-http-oob-encoding-00" class="headerlink" title="D.1.  Changes since draft-reschke-http-oob-encoding-00"></a>D.1.  Changes since draft-reschke-http-oob-encoding-00</h3><p>Mention media type approach.</p>
<p>Explain that clients can always fall back not to use oob when the secondary resource isn’t available.</p>
<p>Add Vary response header field to examples and mention that it’ll usually be needed (<a href="https://github.com/reschke/oobencoding/issues/6" target="_blank" rel="external">https://github.com/reschke/oobencoding/issues/6</a>).</p>
<p>Experimentally add problem reporting using piggy-backed Link header fields (<a href="https://github.com/reschke/oobencoding/issues/7" target="_blank" rel="external">https://github.com/reschke/oobencoding/issues/7</a>).</p>
<h3 id="D-2-Changes-since-draft-reschke-http-oob-encoding-01"><a href="#D-2-Changes-since-draft-reschke-http-oob-encoding-01" class="headerlink" title="D.2.  Changes since draft-reschke-http-oob-encoding-01"></a>D.2.  Changes since draft-reschke-http-oob-encoding-01</h3><p>Updated ENCRYPTENC reference.</p>
<h3 id="D-3-Changes-since-draft-reschke-http-oob-encoding-02"><a href="#D-3-Changes-since-draft-reschke-http-oob-encoding-02" class="headerlink" title="D.3.  Changes since draft-reschke-http-oob-encoding-02"></a>D.3.  Changes since draft-reschke-http-oob-encoding-02</h3><p>Add MICE reference.</p>
<p>Remove the ability of the secondary resource to contain anything but the payload (<a href="https://github.com/reschke/oobencoding/issues/11" target="_blank" rel="external">https://github.com/reschke/oobencoding/issues/11</a>).</p>
<p>Changed JSON payload to be an object containing an array of URIs plus additional members.  Specify “fallback” as one of these additional members, and update Appendix C.1 accordingly).</p>
<p>Discuss extensibility a bit.</p>
<h3 id="D-4-Changes-since-draft-reschke-http-oob-encoding-03"><a href="#D-4-Changes-since-draft-reschke-http-oob-encoding-03" class="headerlink" title="D.4.  Changes since draft-reschke-http-oob-encoding-03"></a>D.4.  Changes since draft-reschke-http-oob-encoding-03</h3><p>Mention “Content Stealing” thread.</p>
<p>Mention padding.</p>
<h3 id="D-5-Changes-since-draft-reschke-http-oob-encoding-04"><a href="#D-5-Changes-since-draft-reschke-http-oob-encoding-04" class="headerlink" title="D.5.  Changes since draft-reschke-http-oob-encoding-04"></a>D.5.  Changes since draft-reschke-http-oob-encoding-04</h3><p>Reduce information leakage by disallowing ambient authority information being sent to the secondary resource.  Require “Origin” to be included in request to secondary resource, and require secondary server to check it.</p>
<p>Mention “Origin” + server check on secondary resource as defense to content stealing.</p>
<p>Update ENCRYPTENC reference, add SCD reference.</p>
<p>Mention fragmentation feature.</p>
<p>Discuss relation with range requests.</p>
<h3 id="D-6-Changes-since-draft-reschke-http-oob-encoding-05"><a href="#D-6-Changes-since-draft-reschke-http-oob-encoding-05" class="headerlink" title="D.6.  Changes since draft-reschke-http-oob-encoding-05"></a>D.6.  Changes since draft-reschke-http-oob-encoding-05</h3><p>Remove redundant Cache-Control: private from one example response (the response payload is encrypted anyway).</p>
<p>Mention looping.</p>
<p>Remove ‘metadata’ payload element.</p>
<p>Align with changes in ENCRYPTENC spec.</p>
<p>Fix incorrect statement about what kind of cookies/credentials can be used in the request to the secondary resource.</p>
<p>Rename “URIs” to “sr” (“secondary resources”) and treat the fallback URI like a regular secondary resource.</p>
<p>Mention reporting protocol ideas.</p>
<h3 id="D-7-Changes-since-draft-reschke-http-oob-encoding-06"><a href="#D-7-Changes-since-draft-reschke-http-oob-encoding-06" class="headerlink" title="D.7.  Changes since draft-reschke-http-oob-encoding-06"></a>D.7.  Changes since draft-reschke-http-oob-encoding-06</h3><p>Changed the link relation name to the fallback resource from “primary” to “fallback”.  Added link relation for reporting TLS handshake failures.</p>
<p>Added an example about the interaction with ‘gzip’ coding.</p>
<p>Update ENCRYPTENC, MICE, and SCD references.</p>
<h3 id="D-8-Changes-since-draft-reschke-http-oob-encoding-07"><a href="#D-8-Changes-since-draft-reschke-http-oob-encoding-07" class="headerlink" title="D.8.  Changes since draft-reschke-http-oob-encoding-07"></a>D.8.  Changes since draft-reschke-http-oob-encoding-07</h3><p>Restrict the valid media types for the response of the secondary server to “application/oob-stream”.</p>
<p>Changed JSON format to allow annotation (optional flags) and entirely new types of entries.</p>
<h3 id="D-9-Changes-since-draft-reschke-http-oob-encoding-08"><a href="#D-9-Changes-since-draft-reschke-http-oob-encoding-08" class="headerlink" title="D.9.  Changes since draft-reschke-http-oob-encoding-08"></a>D.9.  Changes since draft-reschke-http-oob-encoding-08</h3><p>Moved error reporting into appendix (because it’s optional and we’re not sure about the utility of it).  See <a href="https://github.com/EricssonResearch/Blind-Cache-Drafts/issues/4" target="_blank" rel="external">https://github.com/EricssonResearch/Blind-Cache-Drafts/issues/4</a>.</p>
<p>Updated references for ENCRYPTENC, MICE, and SCD.</p>
<p>Mention that we could suppress certain request header fields in the request to the secondary server.</p>
<h2 id="附录-E-致谢"><a href="#附录-E-致谢" class="headerlink" title="附录 E 致谢"></a>附录 E 致谢</h2><p>Thanks to Christer Holmberg, Daniel Lindstrom, Erik Nygren, Goran Eriksson, John Mattsson, Kevin Smith, Magnus Westerlund, Mark Nottingham, Martin Thomson, and Roland Zink for feedback on this document. </p>
<p>作者地址：<br>Julian F. Reschke<br>greenbytes GmbH<br>Hafenweg 16<br>Muenster, NW  48155<br>Germany</p>
<p>EMail: julian.reschke@greenbytes.de<br>URI:   <a href="http://greenbytes.de/tech/webdav/" target="_blank" rel="external">http://greenbytes.de/tech/webdav/</a></p>
<p>Salvatore Loreto<br>Ericsson<br>Torshamnsgatan 21<br>Stochholm  16483<br>Sweden</p>
<p>EMail: salvatore.loreto@ericsson.com</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言&lt;/p&gt;
&lt;p&gt;这篇译文其实是高级计网课的作业，教授要求在 &lt;a href=&quot;ietf.org&quot;&gt;IETF&lt;/a&gt; 上找一篇尚未成为 RFC、也就是还处于草案状态的文档翻译一下。于是笔者随便搜了篇 HTTP 协议相关的文档。翻译完毕后感觉还是有
    
    </summary>
    
      <category term="理论学习" scheme="http://chriscindy.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="HTTP" scheme="http://chriscindy.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>《CSS揭秘》读书总结：背景与边框</title>
    <link href="http://chriscindy.top/post/background-and-border%E2%80%94%E2%80%94reading-notes-of-CSS-secrets/"/>
    <id>http://chriscindy.top/post/background-and-border——reading-notes-of-CSS-secrets/</id>
    <published>2016-11-01T11:25:15.000Z</published>
    <updated>2017-04-21T02:57:52.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>前言:<br>本系列是阅读《CSS揭秘》所作的总结，用以提高知识吸收程度。同时该书本身便是以解决 47 个 CSS 技巧而进行组织的，总结归纳后方便日后查找。</p>
</blockquote>
<h2 id="1-半透明边框"><a href="#1-半透明边框" class="headerlink" title="1. 半透明边框"></a>1. 半透明边框</h2><h3 id="难题"><a href="#难题" class="headerlink" title="难题"></a>难题</h3><p>在 CSS 中使用半透明颜色，可以使用 rgba() 和 hsla()。</p>
<blockquote>
<p>HSL代表色相，饱和度和亮度 - 使用色彩圆柱坐标表示。<br>HSL颜色值指定：HSL（色调，饱和度，明度）。<br>色相是在色轮上的程度（从0到360）-0（或360）是红色的，120是绿色的，240是蓝色的。饱和度是一个百分比值;0％意味着灰色和100％的阴影，是全彩。亮度也是一个百分点;0％是黑色的，100％是白色的。</p>
<p>HSLA的颜色值是一个带有alpha通道的HSL颜色值的延伸 - 指定对象的透明度。<br>指定HSLA颜色值：HSLA（色调，饱和度，亮度，α），α是Alpha参数定义的不透明度。 Alpha参数是一个介于0.0（完全透明）和1.0（完全不透明）之间的参数。</p>
</blockquote>
<p>尽管半透明颜色很受欢迎，但人们对其使用更多集中于背景上。</p>
<p>假设我们想给一个容器设置一层白色背景和一道半透明白色边框，body 的背景会从它的半透明边框透上来。我们最开始的尝试可能是这样的：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">border</span>: 10<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">hsla</span>(0,0%,100%,<span class="selector-class">.5</span>); </div><div class="line"><span class="selector-tag">background</span> : <span class="selector-tag">white</span>;</div></pre></td></tr></table></figure>
<p>结果如下，边框不见了：</p>
<p><img src="http://ww2.sinaimg.cn/large/801b780ajw1f94n0oxe5fj20dw0a0gmk.jpg" alt=""></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>默认状态下，背景会延伸到边框的区域下层，结合下面绿色背景虚线边框的图比较好理解：</p>
<p><img src="http://ww4.sinaimg.cn/large/801b780ajw1f94n53va1lj20e00biq32.jpg" alt=""></p>
<p>这就可以解释我们遇到的难题：body 的背景并没有从内部 content 的半透明的白色半透明边框处透上来，而是在半透明白色边框处透出了这个容器自己的纯白实色背景，这实际上得到的效果跟纯白实色的边框看起来完全一样。</p>
<p>如果要解决这个问题，可以使用 CSS 3 中的 background-clip 属性来进行调整。该属性初始值为 border-box，意味着背景会被元素的 border box（边框的外沿框）裁切掉，如果设置为 padding-box，这样浏览器就会用内边距的外沿来把背景裁切掉。</p>
<p>我们修改代码如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">border</span>: 10<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">hsla</span>(0,0%,100%,<span class="selector-class">.5</span>); </div><div class="line"><span class="selector-tag">background</span> : <span class="selector-tag">white</span>; </div><div class="line"><span class="selector-tag">background-clip</span> : <span class="selector-tag">padding-box</span>;</div></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="http://ww4.sinaimg.cn/large/801b780ajw1f94nc0kc3aj20dq09cwfp.jpg" alt=""></p>
<h2 id="2-多重边框"><a href="#2-多重边框" class="headerlink" title="2.多重边框"></a>2.多重边框</h2><h3 id="难题-1"><a href="#难题-1" class="headerlink" title="难题"></a>难题</h3><p>多重边框的实现很长时间内都需要各种丑陋的 hack，比如使用多个元素来模拟多重边框。在 CSS 代码层面对多重边框进行灵活的调整看起来非常困难。</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li><p><strong>box-shadow 方案</strong></p>
<p>box-shadow 可以接受 6 个参数，如下表所示：</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79gw1f9d1yvo82tj318m0gcmzm.jpg" alt=""></p>
<p>当我们将 spread 属性设为正值，h-shadow、v-shadow 和 blur 均设置为 0，得到的“投影”就像一道实线边框：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span> : <span class="selector-tag">yellowgreen</span>; </div><div class="line"><span class="selector-tag">box-shadow</span> : 0 0 0 10<span class="selector-tag">px</span> <span class="selector-id">#655</span>;</div></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="http://ww4.sinaimg.cn/large/801b780ajw1f94klzchvxj20dq09kjrg.jpg" alt=""></p>
<p>使用 border 也可以实现同样的效果，但 box-shadow 的优势在于：它支持逗号分隔语法，这意味着其可以创建任意数量的投影，所以也就可以创建任意数量的边框。这里在上面的基础上添加一道边框：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">yellowgreen</span>;</div><div class="line"><span class="selector-tag">box-shadow</span>: 0 0 0 10<span class="selector-tag">px</span> <span class="selector-id">#655</span>, 0 0 0 15<span class="selector-tag">px</span> <span class="selector-tag">deeppink</span>;</div></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="http://ww2.sinaimg.cn/large/801b780ajw1f94kvxnctlj20ek0ag0sz.jpg" alt=""></p>
<p>有一处需要注意，box-shadow 是层层叠加的，因此需要按此规律调整 spread 值。比如，上面第一层边框的 spread 值为 10 px，则宽度为 10 px；如果第二层边框的宽度需要设置为 5px，则第二个 box-shadow 的spread 值需要设置为 （10 + 5）即 15 px。</p>
<p>注：</p>
<ul>
<li>投影的行为跟边框不完全一致，因为它不会影响布局，而且也不会受到 box-sizing 属性的影响。如有需要，可以通过内边距或外边距（这取决于投影是内嵌还是外扩的）来额外模拟出边框所需要占据的空间。</li>
<li>使用 box-shadow 创建的边框，其不会响应鼠标事件， 比如悬停或点击。如果需要使其响应鼠标事件，则可以添加 <strong>inset</strong> 关键字，使得 box-shadow 创建的边框出现在内圈，然后留出额外的内边距来填补这些空隙。</li>
</ul>
</li>
<li><p><strong>outline 方案</strong></p>
<p>此方案适用于只创建两层边框的情况。第一层边框使用 border 属性创建，第二层边框使用 outline 属性创建。该方案非常灵活。先看一下 outline 属性可以接受的参数：</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79gw1f9d201qpovj318e0csq4v.jpg" alt=""></p>
<p>对于上面用 box-shadow 实现的两层边框，用 outline 实现的方式如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span> : <span class="selector-tag">yellowgreen</span>; </div><div class="line"><span class="selector-tag">border</span> : 10<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#655</span>; </div><div class="line"><span class="selector-tag">outline</span> : 5<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">deeppink</span>;</div></pre></td></tr></table></figure>
<p>outline 可以和 outline-offset 配合使用，后者用来控制 outline 和元素边缘之间的距离，该属性可以接受负值，对一层 dashed （虚线）outline 使用负的 outline-offset 后，可以得到简单的缝边效果：</p>
<p><img src="http://ww3.sinaimg.cn/large/801b780ajw1f94lm2dme1j20dm09cwem.jpg" alt=""></p>
<p>注：</p>
<ul>
<li>outline 只适用于双层边框</li>
<li>outline 边框不一定会贴合 border-radius 属性产生的圆角。这种行为被 CSS 工作组认为是一个 bug，因此未来可能会改为贴合 border- radius 圆角。</li>
</ul>
</li>
</ol>
<h2 id="3-灵活的背景定位"><a href="#3-灵活的背景定位" class="headerlink" title="3. 灵活的背景定位"></a>3. 灵活的背景定位</h2><h3 id="难题-2"><a href="#难题-2" class="headerlink" title="难题"></a>难题</h3><p>要求针对容器某个角对背景图片做偏移定位，如右下角。在 CSS 2.1 中，只能指定距离左上角的偏移量，或者靠齐到其他三个角。但是如果希望图片和容器的边角之间能留出一定的空隙，此时便比较难解决。</p>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li><p><strong>传统方法</strong></p>
<ul>
<li>对于固定尺寸的容器，可以基于它自身的尺寸以及我们期望它距离右下角的偏移量，计 算出背景图片距离左上角的偏移量，然后再把计算结果设置给 background- position 。</li>
<li>对于尺寸不固定的容器，上述方案无效。</li>
</ul>
</li>
<li><p><strong>background-position 的扩展语法方案</strong></p>
<p>background-position 在 CSS 3 中得到扩展，其允许我们指定背景图片距离任意角的偏移量，只要我们在偏移量前指定关键字，比如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span> : <span class="selector-tag">url</span>(<span class="selector-tag">code-pirate</span><span class="selector-class">.svg</span>) <span class="selector-tag">no-repeat</span> <span class="selector-id">#58a</span>; </div><div class="line"><span class="selector-tag">background-position</span> : <span class="selector-tag">right</span> 20<span class="selector-tag">px</span> <span class="selector-tag">bottom</span> 10<span class="selector-tag">px</span>;</div></pre></td></tr></table></figure>
<p>以上代码表示让背景图片跟右边缘保持 20 px 的偏移量，同时跟底边保持 10px 的偏移量。</p>
<p>对于不支持 background-position 扩展的浏览器，应该为其提供回退方案，在 background 中指定老式的 <code>right bottom</code> 简写值：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span> : <span class="selector-tag">url</span>(<span class="selector-tag">code-pirate</span><span class="selector-class">.svg</span>) <span class="selector-tag">no-repeat</span> <span class="selector-tag">bottom</span> <span class="selector-tag">right</span> <span class="selector-id">#58a</span>; </div><div class="line"><span class="selector-tag">background-position</span> : <span class="selector-tag">right</span> 20<span class="selector-tag">px</span> <span class="selector-tag">bottom</span> 10<span class="selector-tag">px</span>;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>background-origin 方案</strong></p>
<p>对于 <code>background-position: top left</code> 这样的代码，这里的 <code>top left</code> 是相对于元素的 padding box 的左上角。现在我们使用 CSS 3 新增的 background-origin 属性可以指定矩形框是 content-box、padding-box 还是 border-box。比如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">padding</span>: 10<span class="selector-tag">px</span>; </div><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">url</span>("<span class="selector-tag">code-pirate</span><span class="selector-class">.svg</span>") <span class="selector-tag">no-repeat</span> <span class="selector-id">#58a</span> <span class="selector-tag">bottom</span> <span class="selector-tag">right</span>; <span class="comment">/* 或 100% 100% */</span> </div><div class="line"><span class="selector-tag">background-origin</span>: <span class="selector-tag">content-box</span> ;</div></pre></td></tr></table></figure>
<p>当设置 background-origin 为 content-box 时，background-position 属性中使用的边角关键字将会以内容区的边缘作为基准（也就是说，此时背景图片距离边角的偏移量就跟内边距保持一致了）。</p>
</li>
<li><p><strong>calc() 方案</strong></p>
<p>直接上代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span> : <span class="selector-tag">url</span>("<span class="selector-tag">code-pirate</span><span class="selector-class">.svg</span>") <span class="selector-tag">no-repeat</span>; </div><div class="line"><span class="selector-tag">background-position</span> : <span class="selector-tag">calc</span>(100% <span class="selector-tag">-</span> 20<span class="selector-tag">px</span>) <span class="selector-tag">calc</span>(100% <span class="selector-tag">-</span> 10<span class="selector-tag">px</span>);</div></pre></td></tr></table></figure>
<p>以上代码的效果也是让背景图片跟右边缘保持 20 px 的偏移量，同时跟底边保持 10px 的偏移量。</p>
<p>注：在 calc() 函数内部的 - 和 + 运算符的两侧各加 一个空白符，否则会产生解析错误。此举是为了向前兼容：    未来，在 calc() 内部可能会允许使用关键字， 而这些关键字可能会包含连字符（即减号）。</p>
</li>
</ol>
<h2 id="4-边框内圆角"><a href="#4-边框内圆角" class="headerlink" title="4. 边框内圆角"></a>4. 边框内圆角</h2><h3 id="难题-3"><a href="#难题-3" class="headerlink" title="难题"></a>难题</h3><p>有时我们需要一个容器，只在内侧有圆角，而边框或描边的四个角在外 部仍然保持直角的形状，如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/801b780ajw1f94ntx5uk5j20e6066aac.jpg" alt=""></p>
<p>使用两个元素可以实现上述效果，并且很简单：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"something-meaningful"</span>&gt;</span> </div><div class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span> I have a nice subtle inner rounding, don't I look pretty? <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.something-meaningful</span> &#123; <span class="attribute">background </span>: <span class="number">#655</span>; <span class="attribute">padding </span>: .<span class="number">8em</span>; &#125;</div><div class="line"></div><div class="line"><span class="selector-class">.something-meaningful</span> &gt; <span class="selector-tag">div</span> &#123; <span class="attribute">background </span>: tan; <span class="attribute">border-radius </span>: .<span class="number">8em</span>; <span class="attribute">padding </span>: <span class="number">1em</span>; &#125;</div></pre></td></tr></table></figure>
<p>但是如果要求用一个元素实现呢？</p>
<h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span> : <span class="selector-tag">tan</span>; </div><div class="line"><span class="selector-tag">border-radius</span> : <span class="selector-class">.8em</span>; </div><div class="line"><span class="selector-tag">padding</span>: 1<span class="selector-tag">em</span>; </div><div class="line"><span class="selector-tag">box-shadow</span> : 0 0 0 <span class="selector-class">.6em</span> <span class="selector-id">#655</span>; </div><div class="line"><span class="selector-tag">outline</span> : <span class="selector-class">.6em</span> <span class="selector-tag">solid</span> <span class="selector-id">#655</span>;</div></pre></td></tr></table></figure>
<p>其效果和上面两个元素实现的效果一样。究其原因，正如多重边框一节对 outline 属性介绍时提到的，其并不会贴合 border-radius 属性产生的圆角，但是 box-shadow 会。二者叠加到一起，box-shadow 会刚好填补描边和容器圆角之间的空隙。以下两张图分别是单独使用 outline 和 box-shadow 属性的效果：</p>
<p><img src="http://ww1.sinaimg.cn/large/801b780ajw1f94ojbd7huj20e80743yx.jpg" alt=""></p>
<p><img src="http://ww2.sinaimg.cn/large/801b780ajw1f94ojk8syzj20e607kaah.jpg" alt=""></p>
<p>我们为 box-shadow 属性指定的扩张值并不一定等于描边的宽度，我们只需要指定一个足够填补“空隙”的扩张值就可以了。这个值具体是多少？看下图：</p>
<p><img src="http://ww3.sinaimg.cn/large/801b780ajw1f94oz5uwlcj20f809yweo.jpg" alt=""></p>
<p>当圆角半径为 r 时，从圆角的圆心到描边顶角的长度就是 r√2，这意味着投影的扩张半径 spread 值不能小于 r√2 - r = (√2 - 1)r。同时，该值还需要比描边的宽度值小。</p>
<h2 id="5-条纹背景"><a href="#5-条纹背景" class="headerlink" title="5. 条纹背景"></a>5. 条纹背景</h2><h3 id="难题-4"><a href="#难题-4" class="headerlink" title="难题"></a>难题</h3><p>目前在网页中实现条纹图案的方式非常繁琐，并且效果往往不够理想。</p>
<h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li><p><strong>水平条纹</strong></p>
<p>使用 linear-gradient 属性可以创建基本的垂直渐变，比如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;!<span class="selector-tag">--</span>下图一<span class="selector-tag">--</span>&gt;</div><div class="line"><span class="selector-tag">background</span> : <span class="selector-tag">linear-gradient</span>(<span class="selector-id">#fb3</span>, <span class="selector-id">#58a</span>);</div><div class="line"></div><div class="line">&lt;!<span class="selector-tag">--</span>下图二<span class="selector-tag">--</span>&gt;</div><div class="line"><span class="selector-tag">background</span> : <span class="selector-tag">linear-gradient</span>(<span class="selector-id">#fb3</span> 20%, <span class="selector-id">#58a</span> 80%);</div><div class="line"></div><div class="line">&lt;!<span class="selector-tag">--</span>下图三<span class="selector-tag">--</span>&gt;</div><div class="line"><span class="selector-tag">background</span> : <span class="selector-tag">linear-gradient</span>(<span class="selector-id">#fb3</span> 40%, <span class="selector-id">#58a</span> 60%);</div></pre></td></tr></table></figure>
<p>对应效果：</p>
<p><img src="http://ww3.sinaimg.cn/large/801b780ajw1f94scfkualj20dk08u0su.jpg" alt=""></p>
<p><img src="http://ww2.sinaimg.cn/large/801b780ajw1f94sg2c376j20dw0943yp.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/801b780ajw1f94sg9qvibj20dk094t8u.jpg" alt=""></p>
<p>可以发现，当拉近两个色标时，渐变区域越来越窄。不难想象，如果把两个色标重合在一起，得到的就是两条水平条纹。以下是理论依据：</p>
<blockquote>
<p>“如果多个色标具有相同的位置，它们会产生一个无限小的过渡区域， 过渡的起止色分别是第一个和最后一个指定值。从效果上看，颜色会在那 个位置突然变化，而不是一个平滑的渐变过程。”</p>
<p>——CSS 图像（第三版）（<a href="http://w3.org/TR/css3-images）" target="_blank" rel="external">http://w3.org/TR/css3-images）</a></p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span> : <span class="selector-tag">linear-gradient</span>(<span class="selector-id">#fb3</span> 50%, <span class="selector-id">#58a</span> 50%);</div></pre></td></tr></table></figure>
<p>对应效果：</p>
<p><img src="http://ww1.sinaimg.cn/large/801b780ajw1f94sknha8dj20dm08s74b.jpg" alt=""></p>
<p>在此基础上，我们可以进行一些再加工：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!<span class="selector-tag">--</span>可以通过<span class="selector-tag">background-size</span>来调整尺寸<span class="selector-tag">--</span>&gt;</div><div class="line">&lt;!<span class="selector-tag">--</span>背景默认重复平铺，所以整个容器被两条条纹填满<span class="selector-tag">--</span>&gt;</div><div class="line">&lt;!<span class="selector-tag">--</span>如下图一<span class="selector-tag">--</span>&gt;</div><div class="line"><span class="selector-tag">background</span> : <span class="selector-tag">linear-gradient</span>(<span class="selector-id">#fb3</span> 50%, <span class="selector-id">#58a</span> 50%); </div><div class="line"><span class="selector-tag">background-size</span> : 100% 30<span class="selector-tag">px</span>;</div><div class="line"></div><div class="line">&lt;!<span class="selector-tag">--</span>还可以用相同的方法来创建不等宽的条纹，只需调整色标的位置值即可<span class="selector-tag">--</span>&gt;</div><div class="line">&lt;!<span class="selector-tag">--</span>如下图二<span class="selector-tag">--</span>&gt;</div><div class="line"><span class="selector-tag">background</span> : <span class="selector-tag">linear-gradient</span>(<span class="selector-id">#fb3</span> 30%, <span class="selector-id">#58a</span> 30%); </div><div class="line"><span class="selector-tag">background-size</span> : 100% 30<span class="selector-tag">px</span>;</div></pre></td></tr></table></figure>
<p><img src="http://ww3.sinaimg.cn/large/801b780ajw1f94ss8p4c1j20dq08w3yq.jpg" alt=""></p>
<p><img src="http://ww3.sinaimg.cn/large/801b780ajw1f94ssfxyxkj20di09eaaa.jpg" alt=""></p>
<p>针对上面的代码，还可以有改进方案，理论依据如下：</p>
<blockquote>
<p>“如果某个色标的位置值比整个列表中在它之前的色标的位置值都要 小，则该色标的位置值会被设置为它前面所有色标位置值的最大值。”</p>
<p>——CSS 图像（第三版）（<a href="http://w3.org/TR/css3-images）" target="_blank" rel="external">http://w3.org/TR/css3-images）</a></p>
</blockquote>
<p>所以，如果我们把第二个色标的位置值设置为 0，那它的位置就总是会被浏览器调整为前一个色标的位置值。我们可以把原先这样的代码</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span> : <span class="selector-tag">linear-gradient</span>(<span class="selector-id">#fb3</span> 30%, <span class="selector-id">#58a</span> 30%);</div></pre></td></tr></table></figure>
<p>改写成这样：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span> : <span class="selector-tag">linear-gradient</span>(<span class="selector-id">#fb3</span> 30%, <span class="selector-id">#58a</span> 0);</div></pre></td></tr></table></figure>
<p>如果要创建超过两条颜色的条纹，也很容易。以下是生成三条条纹的代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span> : <span class="selector-tag">linear-gradient</span>(<span class="selector-id">#fb3</span> 33<span class="selector-class">.3</span>%, <span class="selector-id">#58a</span> 0, <span class="selector-id">#58a</span> 66<span class="selector-class">.6</span>%, <span class="selector-tag">yellowgreen</span> 0); </div><div class="line"><span class="selector-tag">background-size</span> : 100% 45<span class="selector-tag">px</span>;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p><strong>垂直条纹</strong></p>
<p>垂直条纹相比水平条纹，在 linear-gradient 的开头加一个额外参数来标记其渐变方向即可（在水平条纹中我们没有加这个参数，因为其默认值就是 to bottom，也就是水平条纹的效果）：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span> : <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">to</span> <span class="selector-tag">right</span>, <span class="comment">/* 或 90deg */</span> </div><div class="line"><span class="selector-id">#fb3</span> 50%, <span class="selector-id">#58a</span> 0); </div><div class="line"><span class="selector-tag">background-size</span> : 30<span class="selector-tag">px</span> 100%;</div></pre></td></tr></table></figure>
<p>还需要把 background-size 的值颠倒。</p>
</li>
<li><p><strong>斜向条纹</strong></p>
<p>如果按照常规思维，要实现斜向条纹，改变 linear-gradient 的方向和 background-size 的值，貌似就可以搞定。如果要实现一个 45° 的条纹图案，代码这样写：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">linear-gradient</span>(45<span class="selector-tag">deg</span>,<span class="selector-id">#fb3</span> 50%, <span class="selector-id">#58a</span> 0);</div><div class="line"><span class="selector-tag">background-size</span> : 30<span class="selector-tag">px</span> 30<span class="selector-tag">px</span>;</div></pre></td></tr></table></figure>
<p>得到的效果却是：</p>
<p><img src="http://ww4.sinaimg.cn/large/801b780ajw1f95onvh71lj20ea09adgd.jpg" alt=""></p>
<p>失败的原因是我们仅仅把每个背景单元作了渐变旋转，而没有站在背景整体的角度来看问题。来看预想的斜向背景的单个背景单元：</p>
<p><img src="http://ww3.sinaimg.cn/large/801b780ajw1f95oq87kaaj20do0980th.jpg" alt=""></p>
<p>可以看到，在一个背景单元里，实际上有四条条纹，这样就可以实现条纹无缝衔接：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span> : <span class="selector-tag">linear-gradient</span>(45<span class="selector-tag">deg</span>, <span class="selector-id">#fb3</span> 25%, <span class="selector-id">#58a</span> 0, <span class="selector-id">#58a</span> 50%, <span class="selector-id">#fb3</span> 0, <span class="selector-id">#fb3</span> 75%, <span class="selector-id">#58a</span> 0); <span class="selector-tag">background-size</span> : 30<span class="selector-tag">px</span> 30<span class="selector-tag">px</span>;</div></pre></td></tr></table></figure>
<p>关于条纹变成斜向后为何会看起来变瘦了，实际上是因为背景尺寸设置为 30px 时，产生的条纹宽度将是15/√2  ≈ 10.606 像素。如果需要和原先水平或垂直条纹一样的宽度，在其基础上乘以 √2 即可。</p>
</li>
<li><p><strong>更好的斜向条纹</strong></p>
<p>上面的方案在我们想调整斜向角度时会非常不灵活。这里提供一个更好的方案。首先需要了解的是 linear-gradient() 和 radial-gradient() 各还有一个循环式的加强版：repeating-linear-gradient() 和 repeating-radial-gradient()。其工作方式和前两者类似，只有一点不同：色标是无限循环重复的，直到填满整个背景。比如以下代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span> : <span class="selector-tag">repeating-linear-gradient</span>(45<span class="selector-tag">deg</span>, <span class="selector-id">#fb3</span>, <span class="selector-id">#58a</span> 30<span class="selector-tag">px</span>);</div></pre></td></tr></table></figure>
<p>其实相当于：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">linear-gradient</span>(45<span class="selector-tag">deg</span>, <span class="selector-id">#fb3</span>, <span class="selector-id">#58a</span> 30<span class="selector-tag">px</span>, <span class="selector-id">#fb3</span> 30<span class="selector-tag">px</span>, <span class="selector-id">#58a</span> 60<span class="selector-tag">px</span>, <span class="selector-id">#fb3</span> 60<span class="selector-tag">px</span>, <span class="selector-id">#58a</span> 90<span class="selector-tag">px</span>, <span class="selector-id">#fb3</span> 90<span class="selector-tag">px</span>, <span class="selector-id">#58a</span> 120<span class="selector-tag">px</span>, <span class="selector-id">#fb3</span> 120<span class="selector-tag">px</span>, <span class="selector-id">#58a</span> 150<span class="selector-tag">px</span>, ...);</div></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79jw1f9cqg35mh9j30da08qjrt.jpg" alt=""></p>
<p>第一个好处就是减少了重复，改动颜色时只需要修改两处。另外一点就是现在是在渐变的色标中指定长度，而不是原来的 background-size。因为这些长度是直接在渐变轴上进行度量的，直接代表了条 纹自身的宽度。所以再也不用进行各种数学计算了。</p>
<p>当需要改变角度为 60° 时，只需要这样：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span> : <span class="selector-tag">repeating-linear-gradient</span>(60<span class="selector-tag">deg</span>, <span class="selector-id">#fb3</span>, <span class="selector-id">#fb3</span> 15<span class="selector-tag">px</span>, <span class="selector-id">#58a</span> 0, <span class="selector-id">#58a</span> 30<span class="selector-tag">px</span>);</div></pre></td></tr></table></figure>
<ol>
<li><strong>灵活的同色系条纹</strong></li>
</ol>
<p>当条纹图案由差异不大的颜色组成时，按照上面提供的方法，我们可能需要这样写 CSS：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span> : <span class="selector-tag">repeating-linear-gradient</span>(30<span class="selector-tag">deg</span>, <span class="selector-id">#79b</span>, <span class="selector-id">#79b</span> 15<span class="selector-tag">px</span>, <span class="selector-id">#58a</span> 0, <span class="selector-id">#58a</span> 30<span class="selector-tag">px</span>);</div></pre></td></tr></table></figure>
<p>如图：</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79jw1f9cqtt8kxuj30dm080dfu.jpg" alt=""></p>
<p>实际上，在应对这种情况时，我们可以把最深的颜色指定为背景色，同时把半透明白色的条纹叠加在背景色之上来得到浅色条纹：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span> : <span class="selector-id">#58a</span>; </div><div class="line"><span class="selector-tag">background-image</span> : <span class="selector-tag">repeating-linear-gradient</span>(30<span class="selector-tag">deg</span>, <span class="selector-tag">hsla</span>(0,0%,100%,<span class="selector-class">.1</span>), <span class="selector-tag">hsla</span>(0,0%,100%,<span class="selector-class">.1</span>)    15<span class="selector-tag">px</span>, <span class="selector-tag">transparent</span> 0, <span class="selector-tag">transparent</span> 30<span class="selector-tag">px</span>);</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="6-复杂的背景图案"><a href="#6-复杂的背景图案" class="headerlink" title="6. 复杂的背景图案"></a>6. 复杂的背景图案</h2><h2 id="7-伪随机背景"><a href="#7-伪随机背景" class="headerlink" title="7. 伪随机背景"></a>7. 伪随机背景</h2><h2 id="8-连续的图像边框"><a href="#8-连续的图像边框" class="headerlink" title="8. 连续的图像边框"></a>8. 连续的图像边框</h2><p>请支持正版，购买书籍自行查看。</p>
<p>好吧，其实是我觉得这三章内容 focus 的点太小了，感觉了解一下即可。</p>
<p>好吧，其实是我懒得截图整理了，加上确实 focus 的点太小了，所以就偷个懒啦。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言:&lt;br&gt;本系列是阅读《CSS揭秘》所作的总结，用以提高知识吸收程度。同时该书本身便是以解决 47 个 CSS 技巧而进行组织的，总结归纳后方便日后查找。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-半透明边框&quot;&gt;&lt;a href=&quot;
    
    </summary>
    
      <category term="读书笔记" scheme="http://chriscindy.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CSS" scheme="http://chriscindy.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序的出现给前端带来了什么</title>
    <link href="http://chriscindy.top/post/what-wechat-xiaochengxu-brings-to-front-end/"/>
    <id>http://chriscindy.top/post/what-wechat-xiaochengxu-brings-to-front-end/</id>
    <published>2016-09-22T09:39:49.000Z</published>
    <updated>2017-04-21T02:42:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个前端飞速发展的时代，我比较喜欢将其类比为欧洲列强疯狂殖民扩张的那段历史。JavaScript，得益于所有平台都必须具有浏览器这一特点，已经成为了事实上目前唯一的横跨所有平台的全能语言。现如今，前端圈仍然群雄割据，各种新框架和新概念层出不穷，你方唱罢我登场，而关于前端到底应该以怎么样的形式前进，虽然一些比较基本的观点比如组件化开发、去 DOM 操作等大体达成了一致，但整个大方向到如今依然没有定论。</p>
<p>而在这之外，更值得引起注意的是，前端，确切的说是 Web 开发正在反噬到其他开发领域：Electron 瞄准了桌面客户端、Node.js 是服务端的后起之秀、React Native / Weex 则志在原生移动客户端，而 WebGL 则使得 JS 在刚刚兴起的 VR 领域有了立足之地……</p>
<p>这两天刷屏的微信小程序，体现了腾讯将微信打造成一个超级操作系统的野心，客观上也加剧了 JS 技术栈对于 Native 客户端开发的入侵。前端工程师大喜，因为身价又要涨了，而 iOS / Android 工程师可能略微有点脊背发凉。其实，各种计算机技术或者说语言的兴起与衰落都只是一时的，又有谁能始终屹立在浪潮之巅呢？曾经 iOS 开发的御用语言 Objective C 在 Swift 推出后隐隐有了式微之势，而曾经被视为只能写写特效的玩具语言 JavaScript 现在却风头正劲，俗话说，时势造英雄。放在计算机的世界里，也可以说是时势造语言，或者时势造技术。</p>
<p>所以，作为程序员，更应该多学一些技术，所谓技多不压身。只在一个方向上钻牛角尖固然可能取得较高造诣，然而万一风向变了，依靠一个人的力量逆势而为是收益非常低的事情。就像我一直认为的，小公司将自己的产品依附于大公司的平台上是很愚蠢的，因为指不住哪一天大公司就挂了，或者莫名其妙就把你给潜规则了。最好的规避风险的办法就是全平台发展，Web 端、客户端、微信公众平台（以及其他各种乱七八糟的平台比如支付宝服务窗等等等等）一个都不要落下。这对程序员来说一样适用。计算机发展到如今分支太过庞大，样样精通不现实，但至少应该在精通一到两个方向的基础上再多多涉猎其他领域，不仅是对开拓自己视野有帮助，更重要的是，当行业剧变来临时，你能够全身而退。</p>
<p>前端工程师也一样，因为没准哪天，就有另一种技术来革了我们的命。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个前端飞速发展的时代，我比较喜欢将其类比为欧洲列强疯狂殖民扩张的那段历史。JavaScript，得益于所有平台都必须具有浏览器这一特点，已经成为了事实上目前唯一的横跨所有平台的全能语言。现如今，前端圈仍然群雄割据，各种新框架和新概念层出不穷，你方唱罢我登场，而关于前端
    
    </summary>
    
      <category term="技术感悟" scheme="http://chriscindy.top/categories/%E6%8A%80%E6%9C%AF%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="JavaScript" scheme="http://chriscindy.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中 this 的四条绑定规则</title>
    <link href="http://chriscindy.top/post/the-rule-of-binding-this-in-JavaScript/"/>
    <id>http://chriscindy.top/post/the-rule-of-binding-this-in-JavaScript/</id>
    <published>2016-09-15T08:17:44.000Z</published>
    <updated>2017-04-21T02:34:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ES5 及之前时代的 JavaScript 中 <code>this</code> 的绑定机制是让很多开发者头疼不已的事情。<code>this</code> 的绑定变化多端，让笔者也吃了不少亏。本文根据《你不知道的 JavaScript》上卷中的内容总结了 <code>this</code> 的四条绑定规则，在此记录，以防遗忘。</p>
<h1 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h1><h2 id="1-默认绑定"><a href="#1-默认绑定" class="headerlink" title="1. 默认绑定"></a>1. 默认绑定</h2><p>独立函数调用时，<code>this</code> 指向全局对象，如果使用严格模式，那么全局对象无法使用默认绑定， <code>this</code>绑定至 <code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">foo();  <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>严格模式时：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta">  "use strict"</span>;</div><div class="line">  <span class="built_in">console</span>,log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">foo();  <span class="comment">// TypeError: this is undefined</span></div></pre></td></tr></table></figure>
<h2 id="2-隐式绑定"><a href="#2-隐式绑定" class="headerlink" title="2. 隐式绑定"></a>2. 隐式绑定</h2><p>当函数引用有上下文对象时（即函数作为引用属性被添加到对象中），隐式绑定规则会把函数调用中的 <code>this</code> 绑定到这个上下文对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">2</span>,</div><div class="line">  <span class="attr">foo</span>: foo</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj.foo();  <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>对象属性引用链中只有最顶层或者说最后一层会影响调用位置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj1.obj2.foo();  <span class="comment">// foo 中的 this 与 obj2 绑定</span></div></pre></td></tr></table></figure>
<h3 id="2-1-隐式丢失"><a href="#2-1-隐式丢失" class="headerlink" title="2.1 隐式丢失"></a>2.1 隐式丢失</h3><p>隐式丢失指的是函数中的 <code>this</code> 丢失绑定对象，即它会应用第 1 条的默认绑定规则，从而将 <code>this</code> 绑定到全局对象或者 <code>undefined</code> 上，取决于是否在严格模式下运行。以下情况会发生隐式丢失：</p>
<ul>
<li>绑定至上下文对象的函数被赋值给一个新的函数，然后调用这个新的函数时：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">2</span>,</div><div class="line">  <span class="attr">foo</span>: foo</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = obj.foo; <span class="comment">//函数别名</span></div><div class="line"><span class="keyword">var</span> a = <span class="string">"这是全局变量喔"</span>;</div><div class="line">bar();  <span class="comment">// "这是全局变量喔"</span></div></pre></td></tr></table></figure>
<ul>
<li>传入回调函数时：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  fn();  <span class="comment">// &lt;-- 调用位置</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">2</span>,</div><div class="line">  <span class="attr">foo</span>: foo</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="string">"这是全局变量喔"</span>;</div><div class="line">doFoo( obj.foo );  <span class="comment">// "这是全局变量喔"</span></div></pre></td></tr></table></figure>
<p>其实这就是第一种情况的变种，实际上参数传递就是一种隐式赋值。除了开发人员自定义的函数，在将函数传入语言内置的函数比如 <code>setTimeout</code> 时，同样会发生隐式丢失的情况。</p>
<h2 id="3-显式绑定"><a href="#3-显式绑定" class="headerlink" title="3. 显式绑定"></a>3. 显式绑定</h2><p>显式绑定的核心是 JavaScript 内置的 <code>call(..)</code> 和 <code>apply(..)</code> 方法，这两个方法在 JavaScript 提供的绝大多数函数以及开发者自己创建的所有函数上都可以使用。</p>
<p><code>call(..)</code> 和 <code>apply(..)</code>的第一个参数是一个对象（二者区别在后面传入的参数形式，这里不是重点，不讨论），他们会将 <code>this</code> 绑定到这个对象上。因为你可以直接指定 <code>this</code> 绑定的对象，所以这条规则被称为显式绑定。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">2</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">foo.call(obj);  <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>如果 <code>call</code> 或者 <code>apply</code> 传入的第一个参数是原始值（字符串类型、布尔类型或者数字类型），那么该原始值会被转换成它的对象形式（new String()、new Boolean() 或 new Number()），俗称“装箱”。</p>
<p>显式绑定仍然无法解决丢失绑定问题。</p>
<h3 id="3-1-硬绑定"><a href="#3-1-硬绑定" class="headerlink" title="3.1 硬绑定"></a>3.1 硬绑定</h3><p>作为显式绑定的一个变种，硬绑定可以解决丢失绑定问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">2</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  foo.call(obj);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">bar();  <span class="comment">// 2</span></div><div class="line">setTimeout(bar, <span class="number">100</span>);  <span class="comment">// 2</span></div><div class="line"></div><div class="line">bar.call(<span class="built_in">window</span>);  <span class="comment">//无效，硬绑定的 bar 不会再修改它的 this</span></div></pre></td></tr></table></figure>
<p>在一个新的函数内部强制绑定 this 到某个对象上，无论之后如何调用这个新的函数，其 <code>this</code> 都不会丢失。</p>
<p>典型应用场景为创建一个包裹函数，传入所有的参数并返回接收到的所有值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a, something);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a + something;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>:<span class="number">2</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> foo.call(obj, <span class="built_in">arguments</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> b = bar(<span class="number">3</span>);  <span class="comment">// 2 3</span></div><div class="line"><span class="built_in">console</span>.log(b);  <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<p>或者将绑定的对象改为可配置，这样就成了一个辅助绑定函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">function bind(fn, obj)&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> fn.apply(obj, <span class="built_in">arguments</span>);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>由于硬绑定实在太过常见，所以 ES5 提供了内置的 Function.prototype.bind，其用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a, something);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a + something;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">2</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = foo.bind(obj);</div><div class="line"></div><div class="line"><span class="keyword">var</span> b = bar(<span class="number">3</span>);  <span class="comment">// 2 3</span></div><div class="line"><span class="built_in">console</span>.log(b);  <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<h3 id="3-2-API-调用的“上下文”"><a href="#3-2-API-调用的“上下文”" class="headerlink" title="3.2 API 调用的“上下文”"></a>3.2 API 调用的“上下文”</h3><p>JavaScript 自身以及许多第三方库的函数都提供了一个可选的参数，通常被称为“上下文”，其作用和 <code>bind(..)</code> 一样，确保回调函数使用指定的 <code>this</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">el</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( el, <span class="keyword">this</span>.id);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">id</span>: <span class="string">"awsome"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//调用 foo(..) 时把 this 绑定到 obj</span></div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].forEach(foo, obj);</div><div class="line"><span class="comment">// 1 awsome 2 awsome 3 awsome</span></div></pre></td></tr></table></figure>
<p>实际上这些函数背后还是调用了 <code>call()</code> 或者 <code>apply()</code> ，只不过这样开发者需要写的代码就少了一些。</p>
<h2 id="4-new-绑定"><a href="#4-new-绑定" class="headerlink" title="4. new 绑定"></a>4. new 绑定</h2><p>使用 <code>new</code> 来调用函数时，会自动执行下面的操作：</p>
<ol>
<li>创建一个全新的对象</li>
<li>这个新对象会被执行 [[原型]] 连接</li>
<li>这个新对象会绑定到函数调用的 <code>this</code></li>
<li>如果函数没有返回其他对象，那么 <code>new</code> 表达式中的函数调用会自动返回这个新对象</li>
</ol>
<p>举例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo(<span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(bar.a);  <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>使用 <code>new</code>  来调用 <code>foo(..)</code> 时，会构造一个新对象并把它绑定到 <code>foo(..)</code> 调用中的 <code>this</code> 上。</p>
<h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><p>具体推断细节不再表述，有兴趣的同学可以自行查看《你不知道的 JavaScript》上卷第 2 章。以上四种绑定规则的使用先后推断如下：</p>
<ol>
<li><p>函数是否在 <code>new</code> 中调用（<code>new</code> 绑定）？如果是的话 <code>this</code> 绑定的是新创建的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo();</div></pre></td></tr></table></figure>
</li>
<li><p>函数是否通过 <code>call</code>、<code>apply</code> （显示绑定）或者硬绑定？如果是的话，<code>this</code> 绑定的是指定的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bar = foo.call(obj2);</div></pre></td></tr></table></figure>
</li>
<li><p>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，<code>this</code> 绑定的是那个上下文对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bar = obj1.foo();</div></pre></td></tr></table></figure>
</li>
<li><p>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 <code>undefined</code>，否则绑定到全局对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bar = foo();</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="绑定例外"><a href="#绑定例外" class="headerlink" title="绑定例外"></a>绑定例外</h1><ol>
<li><p>如果把 <code>null</code> 或者 <code>undefined</code> 作为 <code>this</code> 的绑定对象传入 <code>call</code>、<code>apply</code> 或者 <code>bind</code>，那么这些值在调用时会被忽略，实际应用的是默认绑定规则。（书中推荐使用一个空对象来绑定 <code>this</code>）。</p>
</li>
<li><p>间接引用。这种情况容易在赋值时发生：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>；</div><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>: <span class="number">3</span>, <span class="attr">foo</span>: foo&#125;;</div><div class="line"><span class="keyword">var</span> p = &#123;<span class="attr">a</span>: <span class="number">4</span>&#125;;</div><div class="line"></div><div class="line">o.foo();  <span class="comment">// 3</span></div><div class="line">(p.foo = o.foo)();  <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p><code>p.foo()</code> 实际上引用了 <code>foo()</code> ，如此，会应用默认绑定。</p>
</li>
</ol>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>ES6 对改变 <code>this</code> 的混乱绑定作了相应的努力，诞生了箭头函数，其根据当前词法作用域来决定 <code>this</code> 而非上面的四条规则，具体来说，箭头函数会继承外层函数调用的 <code>this</code> 绑定（这其实和 ES6 之前代码中的 <code>self = this</code> 是一个道理）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;ES5 及之前时代的 JavaScript 中 &lt;code&gt;this&lt;/code&gt; 的绑定机制是让很多开发者头疼不已的事情。&lt;code&gt;th
    
    </summary>
    
      <category term="理论学习" scheme="http://chriscindy.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JavaScript" scheme="http://chriscindy.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>深入 MutationObserver</title>
    <link href="http://chriscindy.top/post/learning-MutationObserver/"/>
    <id>http://chriscindy.top/post/learning-MutationObserver/</id>
    <published>2016-09-08T02:42:04.000Z</published>
    <updated>2017-04-21T02:43:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>MutationObserver 给开发者们提供了一种能在某个范围内的 DOM 树发生变化时作出适当反应的能力。该 API 设计用来替换掉在 DOM 3 事件规范中引入的 Mutation 事件。</p>
<p>——MDN</p>
</blockquote>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ul>
<li><p>监视 DOM 变动的接口</p>
<p>当监视的 DOM 发生变动时 MutationObserver 将收到通知并触发事先设定好的回调函数。</p>
</li>
<li><p>类似于事件，但是异步触发</p>
<p>添加监视时，MutationObserver 上的 observer 函数与 addEventListener 有相似之处，但不同于后者的同步触发，MutationObserver 是异步触发，此举是为了避免 DOM 频繁变动导致回调函数被频繁调用，造成浏览器卡顿。</p>
</li>
</ul>
<h2 id="2-MutationObserver-构造函数"><a href="#2-MutationObserver-构造函数" class="headerlink" title="2. MutationObserver 构造函数"></a>2. MutationObserver 构造函数</h2><p>该构造函数用于实例化一个新的 MutaionObserver ，同时指定触发 DOM 变动时的回调函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(callback);</div></pre></td></tr></table></figure>
<p>callback，即回调函数接收两个参数，第一个参数是一个包含了所有 <code>MutationRecord</code> 对象（后文会介绍，别急）的数组，第二个参数则是这个MutationObserver 实例本身。</p>
<h2 id="3-MutationObserver-实例方法"><a href="#3-MutationObserver-实例方法" class="headerlink" title="3. MutationObserver 实例方法"></a>3. MutationObserver 实例方法</h2><h3 id="3-1-Observe-Node-target-optional-MutationObserverInit-options"><a href="#3-1-Observe-Node-target-optional-MutationObserverInit-options" class="headerlink" title="3.1 Observe(Node target, optional MutationObserverInit options);"></a>3.1 <code>Observe(Node target, optional MutationObserverInit options);</code></h3><p>给 MutationObserver 实例添加要观察的 DOM 节点，并可通过一个可选的 options 参数来配置观察哪些变动，该 options 为一个名为 <code>MutationObserverInit</code> 的对象。</p>
<p>以下是 <code>MutationObserverInit</code> 对象的各属性及其描述：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">childList</td>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">是否观察子节点的变动</td>
</tr>
<tr>
<td style="text-align:left">attributes</td>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">是否观察属性的变动</td>
</tr>
<tr>
<td style="text-align:left">characterData</td>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">是否节点内容或节点文本的变动</td>
</tr>
<tr>
<td style="text-align:left">subtree</td>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">是否观察所有后代节点的变动</td>
</tr>
<tr>
<td style="text-align:left">attributeOldValue</td>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">观察 attributes 变动时，是否记录变动前的属性值</td>
</tr>
<tr>
<td style="text-align:left">characterDataOldValue</td>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">观察 characterData 变动时，是否记录变动前的属性值</td>
</tr>
<tr>
<td style="text-align:left">attributeFilter</td>
<td style="text-align:left">Array</td>
<td style="text-align:left">表示需要观察的特定属性（比如[‘class’,’src’]），不在此数组中的属性变化时将被忽略</td>
</tr>
</tbody>
</table>
<p>注：</p>
<ul>
<li>不能单独观察 subtree 变动，必须同时指定 childList、attributes 和 characterData 中的一种或多种。</li>
<li>为同一个 DOM 节点多次添加同一个 MutationObserver 是无效的，回调函数将只被触发一次。但如果指定不同的 options 对象（即观察不同的变动），即被视为不同的 MutationObserver。（是不是感觉跟 addEventListener 确实很像？）</li>
</ul>
<h3 id="3-2-disconnect"><a href="#3-2-disconnect" class="headerlink" title="3.2  disconnect();"></a>3.2  <code>disconnect();</code></h3><p>该方法用来停止观察。后续如果 DOM 节点发生变动将不再触发回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">observer.disconnect();</div></pre></td></tr></table></figure>
<p>继续类比，<code>disconnect</code> 函数和 <code>removeEventListener</code>大致类似，除了 <code>disconnect</code> 函数比较粗暴（无法传参配置），会把该 MutationObserver 实例上所有的观察都停止。</p>
<h3 id="3-3-takeRecords"><a href="#3-3-takeRecords" class="headerlink" title="3.3  takeRecords();"></a>3.3  <code>takeRecords();</code></h3><p>该方法用来清除变动记录，返回一个包含了 <code>MutationRecord</code> 对象的数组。<code>MutationRecord</code> 又出现了。它是啥？</p>
<p>实际上，DOM 每次发生变化，就会生成一条变动记录，这个变动记录对应一个 <code>MutationRecord</code> 对象。以下是 <code>MutationRecord</code> 对象的各属性及其描述：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">type</td>
<td style="text-align:left">String</td>
<td style="text-align:left">根据变动类型，值为 attributes， characterData 或  childList</td>
</tr>
<tr>
<td style="text-align:left">target</td>
<td style="text-align:left">Node</td>
<td style="text-align:left">发生变动的DOM节点</td>
</tr>
<tr>
<td style="text-align:left">addedNodes</td>
<td style="text-align:left">NodeList</td>
<td style="text-align:left">被添加的节点，或者为 null</td>
</tr>
<tr>
<td style="text-align:left">removedNodes</td>
<td style="text-align:left">NodeList</td>
<td style="text-align:left">被删除的节点，或者为 null</td>
</tr>
<tr>
<td style="text-align:left">previousSibling</td>
<td style="text-align:left">Node</td>
<td style="text-align:left">被添加或被删除的节点的前一个兄弟节点，或者为 null</td>
</tr>
<tr>
<td style="text-align:left">nextSibling</td>
<td style="text-align:left">Node</td>
<td style="text-align:left">被添加或被删除的节点的后一个兄弟节点，或者为 null</td>
</tr>
<tr>
<td style="text-align:left">attributeName</td>
<td style="text-align:left">String</td>
<td style="text-align:left">发生变更的属性的本地名称，或者为 null</td>
</tr>
<tr>
<td style="text-align:left">attributeNamespace</td>
<td style="text-align:left">String</td>
<td style="text-align:left">发生变更的属性的命名空间，或者为 null</td>
</tr>
<tr>
<td style="text-align:left">oldValue</td>
<td style="text-align:left">String</td>
<td style="text-align:left">如果 type 为 attributes，则返回该属性变化之前的属性值；如果 type 为 characterData，则返回该节点变化之前的文本数据；如果 type为 childList，则返回 null</td>
</tr>
</tbody>
</table>
<p>前面我们说 MutationObserver 异步处理触发，实际上它的原理就是等待一个脚本任务完成，将这个过程中产生的所有变动记录即所有的 <code>MutationRecord</code> 对象存储到一个数组中，最后再统一处理这个数组。而这个包含了所有变动记录的数组，也将成为回调函数的第一个参数。下面是一个回调函数处理该数组的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params">mutations</span>) </span>&#123;</div><div class="line">  mutations.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">mutation</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(mutation.type);</div><div class="line">  &#125;);    </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="4-兼容性"><a href="#4-兼容性" class="headerlink" title="4. 兼容性"></a>4. 兼容性</h2><p>MutationObserver 在 DOM Level 4 中被引入，其兼容性如下图所示：</p>
<p><img src="http://ww3.sinaimg.cn/large/801b780ajw1f7lc2hbpxjj21kw0m6dka.jpg" alt=""> </p>
<blockquote>
<p>参考文献：</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver" target="_blank" rel="external">MDN MutationObserver</a></p>
<p><a href="http://javascript.ruanyifeng.com/dom/mutationobserver.html" target="_blank" rel="external">《JavaScript 标准参考教程（alpha）》—— MutationObserver</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;MutationObserver 给开发者们提供了一种能在某个范围内的 DOM 树发生变化时作出适当反应的能力。该 API 设计用来替换掉在 DOM 3 事件规范中引入的 Mutation 事件。&lt;/p&gt;
&lt;p&gt;——MDN&lt;/p&gt;
&lt;/blockq
    
    </summary>
    
      <category term="技术研究" scheme="http://chriscindy.top/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="DOM" scheme="http://chriscindy.top/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>采用 gulp 优化 hexo 博客打开速度</title>
    <link href="http://chriscindy.top/post/optimizing-my-blog-by-gulp/"/>
    <id>http://chriscindy.top/post/optimizing-my-blog-by-gulp/</id>
    <published>2016-08-22T09:42:36.000Z</published>
    <updated>2017-04-21T02:56:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>博客搭建这么久了发现并没有进行过优化，首页虽然打开速度勉强能够接受，但是 github 和 coding 提供的空间有限，是时候优化一下了。基本思路是采用 gulp 进行代码的压缩等。</p>
<p>首先需要安装的 gulp 插件有：<code>gulp-clean-css</code> 、<code>gulp-uglify</code>、<code>gulp-htmlmin</code>、<code>gulp-htmlclean</code>。安装它们并将其加入到 package.json 的依赖中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i --save gulp-clean-css gulp-uglify gulp-htmlmin gulp-htmlclean</div></pre></td></tr></table></figure>
<p>当然，你的电脑上需要安装有 gulp,我这里进行了全局安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i -g gulp</div></pre></td></tr></table></figure>
<p>然后在项目的根目录下新建 gulpfile.js 文件，里面一通配置，还是比较简单的，稍微熟悉点 gulp 的都没多大问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</div><div class="line"><span class="keyword">var</span> cleancss = <span class="built_in">require</span>(<span class="string">'gulp-clean-css'</span>);</div><div class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</div><div class="line"><span class="keyword">var</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>);</div><div class="line"><span class="keyword">var</span> htmlclean = <span class="built_in">require</span>(<span class="string">'gulp-htmlclean'</span>);</div><div class="line"></div><div class="line"><span class="comment">/*压缩CSS*/</span></div><div class="line">gulp.task(<span class="string">'minify-css'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.css'</span>)</div><div class="line">    .pipe(cleancss())</div><div class="line">    .pipe(gulp.dest(<span class="string">'./public'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">/*压缩html文件*/</span></div><div class="line">gulp.task(<span class="string">'minify-html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.html'</span>)</div><div class="line">    .pipe(htmlclean())</div><div class="line">    .pipe(htmlmin(&#123;</div><div class="line">      <span class="attr">removeComments</span>: <span class="literal">true</span>,</div><div class="line">      <span class="attr">minifyJS</span>: <span class="literal">true</span>,</div><div class="line">      <span class="attr">minifyCSS</span>: <span class="literal">true</span>,</div><div class="line">      <span class="attr">minifyURLs</span>: <span class="literal">true</span></div><div class="line">    &#125;))</div><div class="line">    .pipe(gulp.dest(<span class="string">'./public'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">/*压缩JS文件*/</span></div><div class="line">gulp.task(<span class="string">'minify-js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.js'</span>)</div><div class="line">    .pipe(uglify())</div><div class="line">    .pipe(gulp.dest(<span class="string">'./public'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'minify-html'</span>, <span class="string">'minify-css'</span>, <span class="string">'minify-js'</span>]);</div></pre></td></tr></table></figure>
<p>大功告成。这样在执行生成命令和部署命令中间加一个 gulp 的命令即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo g</div><div class="line">gulp</div><div class="line">hexo d</div></pre></td></tr></table></figure>
<p>实测发现貌似博客打开速度是快了那么一丢丢。哈哈，就当是有效的吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博客搭建这么久了发现并没有进行过优化，首页虽然打开速度勉强能够接受，但是 github 和 coding 提供的空间有限，是时候优化一下了。基本思路是采用 gulp 进行代码的压缩等。&lt;/p&gt;
&lt;p&gt;首先需要安装的 gulp 插件有：&lt;code&gt;gulp-clean-css
    
    </summary>
    
      <category term="学以致用" scheme="http://chriscindy.top/categories/%E5%AD%A6%E4%BB%A5%E8%87%B4%E7%94%A8/"/>
    
    
      <category term="博客搭建" scheme="http://chriscindy.top/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>babel-register 和 babel-node 的使用</title>
    <link href="http://chriscindy.top/post/the-use-of-babel-register-and-babel-node/"/>
    <id>http://chriscindy.top/post/the-use-of-babel-register-and-babel-node/</id>
    <published>2016-08-22T09:37:28.000Z</published>
    <updated>2017-04-21T02:36:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>Babel 6 中 <code>babel-register</code> 和 <code>babel-node</code> 两个模块是开发时非常好用的转码工具。先来看一下如何使用：</p>
<h4 id="1-babel-register"><a href="#1-babel-register" class="headerlink" title="1. babel-register"></a>1. babel-register</h4><ul>
<li><p>安装：<code>npm install babel-register</code></p>
</li>
<li><p>作用：<code>babel-register</code> 实际上为<code>require</code>加了一个钩子（hook），之后所有被 node 引用的 <code>.es6</code>、<code>.es</code>、<code>.jsx</code> 以及 <code>.js</code> 文件都会先被 Babel 转码。</p>
</li>
<li><p>使用示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//index.js</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//register.js</span></div><div class="line"><span class="built_in">require</span>(<span class="string">"babel-register"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"./index.js"</span>);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node register.js</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-babel-node"><a href="#2-babel-node" class="headerlink" title="2. babel-node"></a>2. babel-node</h4><ul>
<li><p>安装：<code>npm install babel-node</code></p>
</li>
<li><p>作用：替代 CLI 中的 <code>node</code> 命令，可以直接运行采用 ES6 语法编写的代码。</p>
</li>
<li><p>使用示例：</p>
<ul>
<li><p>在 npm <code>scripts</code> 中：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  "scripts": &#123;</div><div class="line">    //"script-name": "node main.js"</div><div class="line">    "script-name": "babel-node main.js"</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在命令行中：</p>
<ul>
<li>全局安装 <code>babel-node</code>：<code>babel-node main.js</code></li>
<li>本地安装 <code>babel-node</code>：<code>./node_modules/.bin/babel-node main.js</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-使用局限"><a href="#3-使用局限" class="headerlink" title="3. 使用局限"></a>3. 使用局限</h4><p>尽管 <code>babel-register</code> 和 <code>babel-node</code> 都非常好用，但是由于二者都是实时转码，因而性能上会有一定影响。官方建议将二者仅置于开发环境下使用。而在正式生产环境中部署时，预先编译代码是值得推荐的做法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Babel 6 中 &lt;code&gt;babel-register&lt;/code&gt; 和 &lt;code&gt;babel-node&lt;/code&gt; 两个模块是开发时非常好用的转码工具。先来看一下如何使用：&lt;/p&gt;
&lt;h4 id=&quot;1-babel-register&quot;&gt;&lt;a href=&quot;#1-ba
    
    </summary>
    
      <category term="技术使用" scheme="http://chriscindy.top/categories/%E6%8A%80%E6%9C%AF%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="Babel" scheme="http://chriscindy.top/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>Babel 6 特性总结</title>
    <link href="http://chriscindy.top/post/the-characteristics-of-Babel-6/"/>
    <id>http://chriscindy.top/post/the-characteristics-of-Babel-6/</id>
    <published>2016-08-22T09:33:53.000Z</published>
    <updated>2017-04-21T02:39:33.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-改进"><a href="#0-改进" class="headerlink" title="0. 改进"></a>0. 改进</h3><ul>
<li><p>模块化</p>
</li>
<li><p>可选的插件</p>
</li>
<li><p>预设</p>
</li>
<li><p>性能改进</p>
</li>
<li><p>插件 API</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Babel 5</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"> &#123;Plugin, types: t&#125; </span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Plugin(<span class="string">'ast-transform'</span>, &#123;</div><div class="line">        <span class="attr">visitor</span>: &#123; ... &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">                      </div><div class="line"><span class="comment">// Babel 6</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"> &#123; types: t&#125; </span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">visitor</span>: &#123; ... &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-安装-Babel-6"><a href="#1-安装-Babel-6" class="headerlink" title="1.安装 Babel 6"></a>1.安装 Babel 6</h3><p><code>npm install</code></p>
<ul>
<li><p><strong>babel-cli</strong></p>
<ul>
<li><p>usage:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">babel app.js</div></pre></td></tr></table></figure>
</li>
<li><p>command: </p>
<ul>
<li>-o –out-file</li>
<li>-d –out-dir</li>
<li>-w –watch</li>
<li>–source-maps</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>babel-register</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//index.js</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//register.js</span></div><div class="line"><span class="built_in">require</span>(<span class="string">"babel-register"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"./index.js"</span>);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node register.js</div></pre></td></tr></table></figure>
<p>注：生产环境不适用 </p>
</li>
<li><p><strong>babel-node</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  "scripts": &#123;</div><div class="line">    //"script-name": "node index.js"</div><div class="line">    "script-name": "babel-node index.js"</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>command:</p>
<ul>
<li>–presets</li>
<li>–plugins</li>
<li>–ignore</li>
</ul>
<p>注：生产环境不适用 </p>
</li>
<li><p><strong>babel-core</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">"babel-core"</span>);</div><div class="line"></div><div class="line">babel.transform(<span class="string">"code();"</span>, options);</div><div class="line"><span class="comment">// =&gt; &#123; code, map, ast &#125;</span></div><div class="line"></div><div class="line">babel.transformFile(<span class="string">"filename.js"</span>, options, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</div><div class="line">  result; <span class="comment">// =&gt; &#123; code, map, ast &#125;</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">babel.transformFileSync(<span class="string">"filename.js"</span>, options);</div><div class="line"><span class="comment">// =&gt; &#123; code, map, ast &#125;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-配置-Babel-6"><a href="#2-配置-Babel-6" class="headerlink" title="2. 配置 Babel 6"></a>2. 配置 Babel 6</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//.babelrc</div><div class="line"></div><div class="line">&#123;</div><div class="line">  "presets": [],</div><div class="line">  "plugins": []</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//or package.json</div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  "babel":&#123;</div><div class="line">    "presets": [],</div><div class="line">  	"plugins": []</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>presets</p>
<ul>
<li>babel-preset-es2015</li>
<li>babel-preset-react</li>
<li>babel-preset-stage-x(x=0,1,2,3)</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"presets"</span>: [</div><div class="line">    <span class="string">"es2015"</span>,</div><div class="line">    <span class="string">"react"</span>,</div><div class="line">    <span class="string">"stage-2"</span></div><div class="line">  ],</div><div class="line">  <span class="attr">"plugins"</span>: []</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>plugins</p>
<ul>
<li>babel-plugin-transform-es2015-classes</li>
<li>babel-plugin-transform-es2015-arrow-functions</li>
<li>…</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   <span class="attr">"plugins"</span>: [</div><div class="line">     <span class="string">"transform-es2015-classes"</span>,</div><div class="line">     <span class="string">"transform-es2015-arrow-functions"</span></div><div class="line">   ]</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>loose mode</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"plugins"</span>: [</div><div class="line">      //<span class="string">"transform-es2015-classes"</span></div><div class="line">      [<span class="string">"transform-es2015-classes"</span>, &#123; <span class="attr">"loose"</span>: <span class="literal">true</span> &#125;]</div><div class="line">    ]</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI3NTE2NjYxNw==&amp;mid=2650600240&amp;idx=1&amp;sn=88f53bf78b5b174acd6805fe7026cd66&amp;scene=1&amp;srcid=0816pFmqA5bQYhJUHdBBMDuq&amp;key=305bc10ec50ec19bea029543ffd48645f5bec6aeefc9ecf044a7e08d510f51dd27c850d970a291e06e17bcfa70f438e0&amp;ascene=0&amp;uin=MTkxMDY2NDA2MQ%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.11.5+build(15F34" target="_blank" rel="external">扩展—— Babel 6 loose</a>&amp;version=11020201&amp;pass_ticket=eUYpNbnbXM9RBSMCUPMk%2FYHjU3v29WWpWF5gQJ9FeU6LHqIZ0eAx6rz%2FawLCrm9c)</p>
</li>
</ul>
</li>
<li><p>基于环境自定义 Babel</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"presets"</span>: [<span class="string">"es2015"</span>],</div><div class="line">  <span class="attr">"plugins"</span>: [],</div><div class="line">  <span class="attr">"env"</span>: &#123;</div><div class="line">    <span class="attr">"development"</span>: &#123;</div><div class="line">      <span class="attr">"plugins"</span>: [...]</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">"production"</span>: &#123;</div><div class="line">      <span class="attr">"plugins"</span>: [...]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>env</code> : <code>process.env.BABEL_ENV</code> or <code>process.env.NODE_env</code></p>
</li>
</ul>
<h3 id="3-Webpack"><a href="#3-Webpack" class="headerlink" title="3. Webpack"></a>3. Webpack</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//webpack.config.js</span></div><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line">    ···</div><div class="line">    <span class="built_in">module</span>.exports = &#123;</div><div class="line">        ···</div><div class="line">        <span class="built_in">module</span>: &#123;</div><div class="line">            <span class="attr">loaders</span>: [</div><div class="line">                &#123;</div><div class="line">                    <span class="attr">loader</span>: <span class="string">'babel-loader'</span>,</div><div class="line">                    <span class="attr">test</span>: path.resolve(__dirname, <span class="string">'js'</span>),</div><div class="line">                    <span class="attr">query</span>: &#123;</div><div class="line">                        <span class="attr">presets</span>: [<span class="string">'es2015'</span>],</div><div class="line">                    &#125;,</div><div class="line">                &#125;</div><div class="line">            ]</div><div class="line">        &#125;,</div><div class="line">        ···</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<ul>
<li>tree-shaking</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0-改进&quot;&gt;&lt;a href=&quot;#0-改进&quot; class=&quot;headerlink&quot; title=&quot;0. 改进&quot;&gt;&lt;/a&gt;0. 改进&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;模块化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可选的插件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;预设&lt;/p&gt;

    
    </summary>
    
      <category term="技术使用" scheme="http://chriscindy.top/categories/%E6%8A%80%E6%9C%AF%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="Babel" scheme="http://chriscindy.top/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>swiftype 搜索服务更换为 Local Search</title>
    <link href="http://chriscindy.top/post/swifttype-search-service-replaced-by-Local-Search/"/>
    <id>http://chriscindy.top/post/swifttype-search-service-replaced-by-Local-Search/</id>
    <published>2016-08-10T06:49:15.000Z</published>
    <updated>2017-04-21T02:31:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>突然发现博客的搜索服务无法使用，查之发现是因为服务提供商 swiftype 目前已经没有了免费账户的选项，15 天试用期结束后如果不付费将无法继续使用。可以选择的账户类型如下：</p>
<p><img src="http://ww4.sinaimg.cn/large/006tKfTcjw1f6onlf2wwxj31kw0qgaf1.jpg" alt="swiftype.jpg"></p>
<p>恕我直言，这是完全不让我们这种小博客用户使用的节奏啊。既然 swiftype 已经无法继续使用，我们只能另寻他路。</p>
<p>Next 的使用文档在 swiftype 之外提供了两种方案：微搜索和 Local Search。</p>
<ul>
<li><p><a href="http://tinysou.com/" target="_blank" rel="external">微搜索</a></p>
<p>国内的一家志在做最好的站内搜索的服务商。截止本文发表时，其官网仍无法注册，进入注册页提示“504 Gateway Time-out”，无奈，放弃。</p>
</li>
</ul>
<ul>
<li><p>Local Search</p>
<p>尝试了一下，还不错，免费，速度堪比 swiftype，Next 定制的外观也还可以，就它了。</p>
<p><img src="http://ww3.sinaimg.cn/large/006tKfTcjw1f6oo7rsw3uj319q116aeu.jpg" alt="localsearch.jpg"></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;突然发现博客的搜索服务无法使用，查之发现是因为服务提供商 swiftype 目前已经没有了免费账户的选项，15 天试用期结束后如果不付费将无法继续使用。可以选择的账户类型如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/006
    
    </summary>
    
      <category term="解决方案" scheme="http://chriscindy.top/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="博客搭建" scheme="http://chriscindy.top/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Babel 6 的 loose 模式</title>
    <link href="http://chriscindy.top/post/the-loose-mode-Babel-6/"/>
    <id>http://chriscindy.top/post/the-loose-mode-Babel-6/</id>
    <published>2016-08-10T06:32:49.000Z</published>
    <updated>2017-04-21T02:40:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006tKfTcjw1f6omyfzq3qj31kw0pu7av.jpg" alt="babel.png"></p>
<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>Babel 的 loose 模式将 ES6 代码转译成 ES5 代码，loose 模式是不太忠实于 ES6 语义的。这篇文章解释了它是怎么工作的以及它的优点与缺点（剧透：通常是不推荐的）。</p>
<p>在这之前，我们先简单了解一下 Babel 中的一些基础知识：</p>
<ul>
<li><p>配置文件</p>
<p>Babel 的配置文件是<code>.babelrc</code>，存放在下项目的根目录下，该文件用来设置预设和插件，基本格式如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"presets"</span>:[],</div><div class="line">  <span class="attr">"plugins"</span>:[]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>presets（预设）</p>
<p>为了将 Babel 的输出配置为符合要求的情况，我们需要指定 Babel 使用什么插件。可以指定的有：</p>
<ul>
<li>单独的插件</li>
<li>预设，即支持各种编译方案的插件集合。</li>
</ul>
<p>下面是一些使用广泛的预设：</p>
<ul>
<li>es2015：将 ES6 代码编译为 ES5</li>
<li>stage-3：将<code>stage 3 ECMAScript proposals</code>编译为ES5</li>
<li>react：将 JSX 编译为 JavaScript 并且移除 Flow 的类型注解</li>
</ul>
<p>预设通过 npm 安装。他们在 npm 中的包名称为其名字加上前缀<code>babel-preset-</code>。比如安装<code>es2015</code>时，我们可以用以下的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install babel-preset-es2015</div></pre></td></tr></table></figure>
</li>
<li><p>plugins（插件）</p>
<p>笼统地讲，插件是在编译过程中应用到输入中的函数。插件有两种重要的类别：</p>
<ul>
<li><p>语法插件。其作用为使 Babel 具备处理内建基础语法之外的语法实体。它们能够帮助构造抽象语法树（AST）。典型的语法插件有：<a href="http://babeljs.io/docs/plugins/syntax-async-functions/" target="_blank" rel="external">syntax-async-functions</a> 以及 <a href="http://babeljs.io/docs/plugins/syntax-jsx/" target="_blank" rel="external">syntax-jsx</a>。</p>
</li>
<li><p>转换插件。其作用为修改抽象语法树。典型的转换插件有：<a href="http://babeljs.io/docs/plugins/transform-async-to-generator/" target="_blank" rel="external">transform-async-to-generator</a>、<a href="http://babeljs.io/docs/plugins/transform-react-jsx/" target="_blank" rel="external">transform-react-jsx</a>、<a href="http://babeljs.io/docs/plugins/transform-es2015-arrow-functions/" target="_blank" rel="external">transform-es2015-arrow-functions</a> 等。</p>
<p>如果你想编译不包含在基础语法之内的代码，那你将同时需要一个语法插件以及与之相对应的转换插件。不过，每个依赖于语法插件的转换插件都将自动触发该语法插件。</p>
<p>插件同样通过 npm 安装，他们在 npm 中的包名称为其名字加上前缀<code>babel-plugin-</code>：</p>
<ul>
<li>安装插件<code>syntax-jsx</code>：<code>npm install babel-plugin-syntax-jsx</code></li>
<li>安装插件<code>transform-react-jsx</code>：<code>npm install babel-plugin-transform-react-jsx</code>​</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>OK，基础知识介绍到这里，如想进一步学习 Babel，可以去到<a href="https://babeljs.io/" target="_blank" rel="external">Babel官网</a>。下面回归主题，探究 Babel 6 的 loose 模式。</p>
<h3 id="2-两种模式"><a href="#2-两种模式" class="headerlink" title="2. 两种模式"></a>2. 两种模式</h3><p>许多 Babel 的插件有两种模式：</p>
<p> • 尽可能符合 ECMAScript6 语义的 normal 模式。</p>
<p> • 提供更简单 ES5 代码的 loose 模式。</p>
<p>通常，推荐不使用 loose 模式，使用这种模式的优点和缺点是：</p>
<p> • 优点：生成的代码可能更快，对老的引擎有更好的兼容性，代码通常更简洁，更加的“ES5化”。</p>
<p> • 缺点：你是在冒险——随后从转译的 ES6 到原生的 ES6 时你会遇到问题。这个险是很不值得冒的。</p>
<h4 id="2-1-切换到-loose-模式"><a href="#2-1-切换到-loose-模式" class="headerlink" title="2.1 切换到 loose 模式"></a>2.1 切换到 loose 模式</h4><p><a href="https://github.com/bkonkle/babel-preset-es2015-loose" target="_blank" rel="external">es2015-loose</a> 是标准的 ES6 预设（preset）es2015 的 loose 版。<a href="https://github.com/bkonkle/babel-preset-es2015-loose/blob/master/index.js" target="_blank" rel="external">这个预设的代码</a>对什么样的插件有 loose 模式以及怎样开启提供了很好的说明。以下是代码截选：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    <span class="attr">plugins</span>: [</div><div class="line">      ···</div><div class="line">      [<span class="built_in">require</span>(<span class="string">"babel-plugin-transform-es2015-classes"</span>), &#123;<span class="attr">loose</span>: <span class="literal">true</span>&#125;],</div><div class="line">      <span class="built_in">require</span>(<span class="string">"babel-plugin-transform-es2015-object-super"</span>),</div><div class="line">      ···</div><div class="line">    ]</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这是一个 CommonJS 模块，可以使用任何的 ECMAScript 5，如果你通过<code>.babelrc</code> 或者<code>package.json</code>配置 babel（<a href="http://www.2ality.com/2015/11/configuring-babel6.html" target="_blank" rel="external">详细配置</a>），你需要使用 JSON。也可以包含 preset：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">···</div><div class="line">  "presets": [</div><div class="line">    ···</div><div class="line">    "es2015-loose",</div><div class="line">    ···</div><div class="line">  ],</div><div class="line"> ···</div></pre></td></tr></table></figure></p>
<p>也可以单独引入插件：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">···</div><div class="line"> "plugins": [</div><div class="line">   ···</div><div class="line">   ["transform-es2015-classes", &#123;loose: true&#125;],</div><div class="line">   "transform-es2015-object-super",</div><div class="line">   ···</div><div class="line"> ],</div><div class="line"> ···</div></pre></td></tr></table></figure></p>
<h3 id="3-例子：normal-模式与-loose-模式的输出"><a href="#3-例子：normal-模式与-loose-模式的输出" class="headerlink" title="3. 例子：normal 模式与 loose 模式的输出"></a>3. 例子：normal 模式与 loose 模式的输出</h3><p>让我们看看模式如何影响下面代码的编译：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">        <span class="keyword">this</span>.x = x;</div><div class="line">        <span class="keyword">this</span>.y = y;</div><div class="line">    &#125;</div><div class="line">    toString() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">`(<span class="subst">$&#123;<span class="keyword">this</span>.x&#125;</span>, <span class="subst">$&#123;<span class="keyword">this</span>.y&#125;</span>)`</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3-1-normal-模式"><a href="#3-1-normal-模式" class="headerlink" title="3.1 normal 模式"></a>3.1 normal 模式</h4><p>在 normal 模式下，类的 prototype 方法是通过<code>Object.defineProperty</code>添加的（第 A 行），来确保它们是不可以被枚举的，这是 ES6 规范所要求的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> _createClass = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">defineProperties</span>(<span class="params">target, props</span>) </span>&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.length; i++) &#123;</div><div class="line">                <span class="keyword">var</span> descriptor = props[i];</div><div class="line">                descriptor.enumerable = descriptor.enumerable || <span class="literal">false</span>;</div><div class="line">                descriptor.configurable = <span class="literal">true</span>;</div><div class="line">                <span class="keyword">if</span> (<span class="string">"value"</span> <span class="keyword">in</span> descriptor) descriptor.writable = <span class="literal">true</span>;</div><div class="line">                <span class="built_in">Object</span>.defineProperty(target, descriptor.key, descriptor);   <span class="comment">// (A)</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, protoProps, staticProps</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (protoProps) defineProperties(Constructor.prototype, protoProps);</div><div class="line">            <span class="keyword">if</span> (staticProps) defineProperties(Constructor, staticProps);</div><div class="line">            <span class="keyword">return</span> Constructor;</div><div class="line">        &#125;;</div><div class="line">    &#125;)();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot call a class as a function"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> Point = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">            _classCallCheck(<span class="keyword">this</span>, Point);</div><div class="line"></div><div class="line">            <span class="keyword">this</span>.x = x;</div><div class="line">            <span class="keyword">this</span>.y = y;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        _createClass(Point, [&#123;</div><div class="line">            <span class="attr">key</span>: <span class="string">"toString"</span>,</div><div class="line">            <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> <span class="title">toString</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="string">"("</span> + <span class="keyword">this</span>.x + <span class="string">", "</span> + <span class="keyword">this</span>.y + <span class="string">")"</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;]);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> Point;</div><div class="line">    &#125;)();</div></pre></td></tr></table></figure></p>
<h4 id="3-2-loose-模式"><a href="#3-2-loose-模式" class="headerlink" title="3.2 loose 模式"></a>3.2 loose 模式</h4><p>在 loose 模式下，用通常的赋值方式添加方法（第 B 行），这种风格更像你用 ES5 手动编写代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta"> "use strict"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123; ··· &#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Point = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">        _classCallCheck(<span class="keyword">this</span>, Point);</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.x = x;</div><div class="line">        <span class="keyword">this</span>.y = y;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Point.prototype.toString = <span class="function"><span class="keyword">function</span> <span class="title">toString</span>(<span class="params"></span>) </span>&#123;   <span class="comment">// (B)</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"("</span> + <span class="keyword">this</span>.x + <span class="string">", "</span> + <span class="keyword">this</span>.y + <span class="string">")"</span>;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> Point;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>参考文献：</p>
<blockquote><footer><strong>wd4blue</strong><cite><a href="http://www.w3ctech.com/topic/1708?utm_source=tuicool&utm_medium=referral" target="_blank" rel="external">Babel 6: loose 模式</a></cite></footer></blockquote>
<blockquote><footer><strong>2ality</strong><cite><a href="http://www.2ality.com/2015/11/configuring-babel6.html" target="_blank" rel="external">Configuring Babel 6</a></cite></footer></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006tKfTcjw1f6omyfzq3qj31kw0pu7av.jpg&quot; alt=&quot;babel.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;hea
    
    </summary>
    
      <category term="技术研究" scheme="http://chriscindy.top/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Babel" scheme="http://chriscindy.top/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>Riot.js 特性一览</title>
    <link href="http://chriscindy.top/post/characteristics-of-Riotjs/"/>
    <id>http://chriscindy.top/post/characteristics-of-Riotjs/</id>
    <published>2016-07-29T08:11:36.000Z</published>
    <updated>2017-04-21T02:39:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>注：本文基于Riot.js v2.5.0版本</p>
</blockquote>
<h2 id="Riot-js简介"><a href="#Riot-js简介" class="headerlink" title="Riot.js简介"></a>Riot.js简介</h2><ul>
<li><p>类似 React 的 <strong>微型</strong> UI 库</p>
</li>
<li><p>自定义标签/虚拟 DOM</p>
</li>
<li><p>适合编写独立组件</p>
</li>
<li><p>MVP 架构</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNbRwjw1f69ltjvz8mj30jg042jrh.jpg" alt="MVP 架构图"></p>
</li>
<li><p>支持 IE9+ ？？</p>
</li>
</ul>
<h2 id="1-自定义标签"><a href="#1-自定义标签" class="headerlink" title="1.自定义标签"></a>1.自定义标签</h2><ol>
<li>布局与逻辑耦合，可重用组件</li>
<li>实际上的语法糖—&gt;编译为 JS</li>
<li><p>虚拟 DOM</p>
<ul>
<li>单向的数据传输： update 或 unmount 都是从 父亲-&gt;孩子</li>
<li>预编译和缓存表达式，解析更加高效</li>
<li>预处理器</li>
<li>可用于服务器端</li>
</ul>
</li>
<li>语法友好<ul>
<li>强大的属性缩写: class={enable: true, hidden: false}</li>
<li>不需要额外的手动绑定，无需记忆 render，state，constructor 等</li>
<li>可插值使用: Add #{items.length + 1} 或 class=”item {selectd: true}”</li>
<li>逻辑代码，可不放在 script 标签内</li>
<li>可使用部分 ES6（完全使用需结合 Babel）</li>
</ul>
</li>
</ol>
<h2 id="2-mixin"><a href="#2-mixin" class="headerlink" title="2.mixin"></a>2.mixin</h2><p>Mixin 可以将公共代码在不同标签之间方便地共享，可以混入 Object 和 new function(){}。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> OptsMixin = &#123;</div><div class="line">    <span class="attr">init</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">this</span>.on(<span class="string">'updated'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'Updated!'</span>) &#125;)</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">getOpts</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.opts</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">setOpts</span>: <span class="function"><span class="keyword">function</span>(<span class="params">opts, update</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.opts = opts</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(!update) &#123;</div><div class="line">            <span class="keyword">this</span>.update()</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;my-tag&gt;</div><div class="line">    &lt;h1&gt;&#123; opts.title &#125;&lt;/h1&gt;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.mixin(OptsMixin)</div><div class="line">&lt;<span class="regexp">/my-tag&gt;</span></div></pre></td></tr></table></figure>
<p>声明式 mixin 可在文件之间和项目之间共享 mixin：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">riot.mixin(<span class="string">"defaultData"</span>, &#123;</div><div class="line">    <span class="attr">author</span>: <span class="string">"ddfe"</span>,</div><div class="line">    <span class="attr">email</span>: <span class="string">"shield@didichuxing.com"</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// in custom tag</span></div><div class="line"><span class="keyword">this</span>.mixin(<span class="string">"defaultData"</span>);</div></pre></td></tr></table></figure>
<h2 id="3-事件"><a href="#3-事件" class="headerlink" title="3.事件"></a>3.事件</h2><ul>
<li><p>自定义标签创建过程：</p>
<ol>
<li>创建标签实例</li>
<li>标签定义中的 JavaScript 被执行</li>
<li>HTML 中的表达式被首次计算并首次触发 “update” 事件</li>
<li>标签被加载 (mount) 到页面上，触发 “mount” 事件</li>
</ol>
</li>
<li><p>监听生命周期事件</p>
<ul>
<li>before-mount </li>
<li>mount</li>
<li>update（改写上下文数据）</li>
<li>updated（操作 DOM）</li>
<li>before-mount</li>
<li>unmount</li>
</ul>
</li>
<li><p>表达式更新方式：</p>
<ol>
<li>当一个事件处理器被调用后自动更新。可以在事件处理器中设置 <code>e.preventUpdate = true</code> 来禁止这种行为。</li>
<li>当前标签实例的 <code>this.update()</code> 方法被调用时</li>
<li>当前标签的任何一个祖先的 <code>this.update()</code> 被调用时. 更新从父亲到儿子单向传播。</li>
<li>当 <code>riot.update()</code> 方法被调用时, 会更新页面上所有的表达式。</li>
</ol>
<p>​</p>
<p>​</p>
</li>
</ul>
<h2 id="4-表达式"><a href="#4-表达式" class="headerlink" title="4.表达式"></a>4.表达式</h2><p>100%纯 JavaScript：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123; title || <span class="string">'Untitled'</span> &#125;</div><div class="line">&#123; results ? <span class="string">'ready'</span> : <span class="string">'loading'</span> &#125;</div><div class="line">&#123; <span class="keyword">new</span> <span class="built_in">Date</span>() &#125;</div><div class="line">&#123; message.length &gt; <span class="number">140</span> &amp;&amp; <span class="string">'Message is too long'</span> &#125;</div><div class="line">&#123; <span class="built_in">Math</span>.round(rating) &#125;</div></pre></td></tr></table></figure>
<p>可放在 html 节点中，也可作为文本节点嵌入：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&#123;</span> /* 属性表达式 */ &#125;&gt;</span></div><div class="line">  &#123; /* 嵌入表达式 */ &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></div></pre></td></tr></table></figure>
<p>注：可通过<code>riot.settings.brackets</code>自定义花括号</p>
<h2 id="5-杂烩"><a href="#5-杂烩" class="headerlink" title="5.杂烩"></a>5.杂烩</h2><ul>
<li><p>嵌套标签</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;account&gt;</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">subscription</span>  <span class="attr">plan</span>=<span class="string">&#123;</span> <span class="attr">opts.plan</span> &#125; <span class="attr">show_details</span>=<span class="string">"true"</span> /&gt;</span></span></div><div class="line"><span class="tag">&lt;/<span class="name">account</span>&gt;</span></div><div class="line"></div><div class="line">&lt;subscription&gt;</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123; opts.plan.name &#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></div><div class="line">  <span class="comment">// 取得标签选项</span></div><div class="line">  <span class="keyword">var</span> plan = opts.plan,</div><div class="line">      show_details = opts.show_details</div><div class="line">  <span class="comment">// 访问父标签实例</span></div><div class="line">  <span class="keyword">var</span> parent = <span class="keyword">this</span>.parent</div><div class="line">&lt;<span class="regexp">/subscription&gt;</span></div></pre></td></tr></table></figure>
<p>父标签的参数通过 <code>riot.mount</code> 方法的参数设置，而子标签的选项通过标签属性来传递。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">riot.mount(<span class="string">'account'</span>, &#123; <span class="attr">plan</span>: &#123; <span class="attr">name</span>: <span class="string">'ddfe'</span>, <span class="attr">age</span>: <span class="string">'4'</span> &#125; &#125;)</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>嵌套HTML</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--definition--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">my-tag</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">yield</span>/&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  this.text = 'world'</div><div class="line"><span class="tag">&lt;/<span class="name">my-tag</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--apply--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">my-tag</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">b</span>&gt;</span>&#123; text &#125;<span class="tag">&lt;/<span class="name">b</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">my-tag</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--result--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">my-tag</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">b</span>&gt;</span>world<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">my-tag</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>带有 <code>name</code> 或 <code>id</code> 属性的 DOM 元素将自动被绑定到上下文中，可直接访问</p>
</li>
<li><p>事件处理器 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;login&gt;</div><div class="line">  &lt;form onsubmit=&#123; submit &#125;&gt;</div><div class="line">  &lt;/form&gt;</div><div class="line"></div><div class="line">  // 上面的表单提交时调用此方法</div><div class="line">  submit(e) &#123;</div><div class="line">  &#125;</div><div class="line">&lt;/login&gt;</div><div class="line"></div><div class="line">//e.currentTarget 事件处理器的所属元素</div><div class="line">//e.target 发起事件的元素</div><div class="line">//e.which 键盘事件中的键值 </div><div class="line">//e.item 循环中的当前元素</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>渲染条件：<code>if = {expression}</code> <code>show</code> <code>hide</code></p>
</li>
<li><p>循环：<code>each = {items}</code>（对象数组）or <code>each = {name, i in items}</code>(非对象数组) or <code>each = {name,value in items}</code>（对象）（不建议使用）</p>
<p>循环中的每一项将建立一个新的上下文，子标签通过 parent 访问父标签定义的方法和属性。</p>
</li>
<li><p>使用标准 HTML 元素作为标签</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;ul riot-tag=<span class="string">"my-tag"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></div><div class="line"></div><div class="line">riot.mount(<span class="string">'my-tag'</span>)</div></pre></td></tr></table></figure>
</li>
<li><p>服务端渲染</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> riot = <span class="built_in">require</span>(<span class="string">'riot'</span>)</div><div class="line"><span class="keyword">var</span> timer = <span class="built_in">require</span>(<span class="string">'timer.tag'</span>)</div><div class="line"></div><div class="line"><span class="keyword">var</span> html = riot.render(timer, &#123; <span class="attr">start</span>: <span class="number">42</span> &#125;)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(html) <span class="comment">// &lt;timer&gt;&lt;p&gt;Seconds Elapsed: 42&lt;/p&gt;&lt;/timer&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="6-编译"><a href="#6-编译" class="headerlink" title="6. 编译"></a>6. 编译</h2><p>自定义标签会被编译为 JavaScript</p>
<ul>
<li><p>浏览器内编译</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">"todo.tag"</span> type=<span class="string">"riot/tag"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>预编译：riot 命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">npm install riot -g</div><div class="line"></div><div class="line"># 编译到当前目录</div><div class="line">riot some.tag</div><div class="line"></div><div class="line"># 编译到目标目录</div><div class="line">riot some.tag some_folder</div><div class="line"></div><div class="line"># 编译到目标路径</div><div class="line">riot some.tag some_folder/some.js</div><div class="line"></div><div class="line"># 将源目录下的所有文件编译至目的目录</div><div class="line">riot some/folder path/to/dist</div><div class="line"></div><div class="line"># 将源目录下的所有文件编译（合并）到单个js文件</div><div class="line">riot some/folder all-my-tags.js</div><div class="line"></div><div class="line">参数：</div><div class="line">-w watch 目录 有变化自动编译</div><div class="line">-ext html 指定后缀名</div><div class="line">--config config 使用config.js作配置文件</div><div class="line">--type 指定 js 处理器</div><div class="line">--template 指定 HTML 模板</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>预处理器</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"coffee"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<h2 id="7-观察者-Observable（事件触发器）"><a href="#7-观察者-Observable（事件触发器）" class="headerlink" title="7.观察者 Observable（事件触发器）"></a>7.观察者 Observable（事件触发器）</h2><p>Riot 提供 Observable 以便组件间通信，实现模块化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法1，创建一个观察者，返回一个实例，之后该对象便可以触发和监听事件</span></div><div class="line"><span class="keyword">var</span> ddfe = riot.observable(&#123;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//方法2，使 ddfe 成为观察者</span></div><div class="line">riot.observable(ddfe);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 监听事件</span></div><div class="line">ddfe.on(<span class="string">"event1"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data1, data2</span>)</span>&#123;</div><div class="line">    <span class="comment">// 监听event1事件</span></div><div class="line">    <span class="comment">// data1 和 data2 是trigger传入的参数</span></div><div class="line">    <span class="comment">// data1 = 1, data2 = 2</span></div><div class="line">    <span class="built_in">console</span>.log(data1, data2);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 发布一个事件</span></div><div class="line"><span class="comment">// 该事件带有 1 和 2 作为参数</span></div><div class="line"><span class="comment">// 上面的on("event1")的回调fn将会执行</span></div><div class="line">ddfe.trigger(<span class="string">"event1"</span>, <span class="number">1</span>, <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="comment">// 解除 event1 的所有监听，第二个参数可选</span></div><div class="line"><span class="comment">// 如果有第二个参数 [function]，则只解绑该函数</span></div><div class="line">ddfe.off(<span class="string">"event1"</span>);</div><div class="line"></div><div class="line"><span class="comment">// one 与 on 类似，只是 one 如果执行过一次，就自动解除绑定</span></div><div class="line">ddfe.one(<span class="string">"event1"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data1</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data1);</div><div class="line">&#125;);</div><div class="line">ddfe.trigger(<span class="string">"event1"</span>, <span class="number">1</span>, <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="comment">//删除所有事件的所有监听器</span></div><div class="line">ddfe.off(<span class="string">'*'</span>)</div><div class="line"></div><div class="line"><span class="comment">//对所有的事件删除指定的回调函数</span></div><div class="line">ddfe.off(<span class="string">'*'</span>,fn)</div></pre></td></tr></table></figure>
<h2 id="8-路由"><a href="#8-路由" class="headerlink" title="8.路由"></a>8.路由</h2><p>一个最小化的路由器实现</p>
<p>功能：</p>
<ol>
<li>修改 URL 的 hash 部分</li>
<li>hash 变化时进行通知</li>
<li>查看当前 hash</li>
</ol>
<p>API：</p>
<ol>
<li><p><code>riot.route(callback)</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">riot.route(<span class="function"><span class="keyword">function</span>(<span class="params">collection, id, action</span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//如果 url 变为 customers/987987/edit,则</span></div><div class="line"></div><div class="line"><span class="comment">//collection = 'customers'</span></div><div class="line"></div><div class="line"><span class="comment">//id = '987987'</span></div><div class="line"></div><div class="line"><span class="comment">//action = 'edit'</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>riot.route(filter, callback)</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 精确匹配 `/fruit`</span></div><div class="line">riot.route(<span class="string">'/fruit'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'The list of fruits'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 如果 url 变成 `/blog/2015-09/01`,</span></div><div class="line"><span class="comment">// 回调的参数将被捕捉成 '2015', '09' 和 '01'</span></div><div class="line">riot.route(<span class="string">'/blog/*-*/*'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">year, month, date</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'The page of '</span> + year + <span class="string">'-'</span> + month + <span class="string">'-'</span> date)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p><code>riot.route.create()</code></p>
<p>   返回一个新的路由上下文</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">first-tag</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>First tag<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> subRoute = riot.route.create() <span class="comment">// 创建新的路由上下文</span></div><div class="line">    subRoute(<span class="string">'/fruit/*'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">      <span class="comment">/* 公用的部分 */</span></div><div class="line">    &#125;)</div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">first-tag</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">second-tag</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Second tag<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> subRoute = riot.route.create() <span class="comment">// 创建新的路由上下文</span></div><div class="line">    subRoute(<span class="string">'/fruit/apple'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">      <span class="comment">/* 个别的部分 */</span></div><div class="line">    &#125;)</div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">second-tag</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>riot.route(to[, title, shouldReplace])</code></p>
<pre><code>在内部实现中，
</code></pre><ul>
<li>如果没有 <code>shouldReplace</code>, 将使用 <code>history.pushState()</code>.</li>
<li>如果有 <code>shouldReplace</code>, 将使用<code>history.replaceState()</code>.</li>
</ul>
</li>
<li><p><code>riot.route.start()</code></p>
<p>   开始监听路由变化，需要手动调用</p>
</li>
<li><p><code>riot.route.start(autoExec)</code></p>
<p>   riot.route.start(true) &lt;=&gt; riot.route.start()+riot.route.exec()</p>
</li>
<li><p><code>riot.route.stop()</code></p>
</li>
<li><p><code>riot.route.query()</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果 url 变成 `/search?keyword=Apple&amp;limit=30` 将会匹配</span></div><div class="line">riot.route(<span class="string">'/search..'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> q = riot.route.query()</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Search keyword: '</span> + q.keyword)</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Search limit: '</span> + q.limit)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p><code>riot.route.base(base)</code>修改基础路径</p>
</li>
<li><p><code>riot.route.parser(parser[, secondParser])</code></p>
</li>
<li><p>其他，路由优先级等</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">riot.route(<span class="string">'/fruit/apple'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* */</span> &#125;) <span class="comment">// 路由-B (1)</span></div><div class="line">riot.route(<span class="string">'/fruit/orange'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* */</span> &#125;) <span class="comment">// 路由-C (2)</span></div><div class="line">riot.route(<span class="string">'/fruit/*'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123; <span class="comment">/* */</span> &#125;) <span class="comment">// 路由-A (3)</span></div><div class="line"></div><div class="line">riot.route(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* */</span> &#125;) <span class="comment">// 路由-X (3)</span></div><div class="line">riot.route(<span class="string">'/fruit/*'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* */</span> &#125;) <span class="comment">// 路由-Y (1)</span></div><div class="line">riot.route(<span class="string">'/sweet/*'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* */</span> &#125;) <span class="comment">// 路由-Z (2)</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注：本文基于Riot.js v2.5.0版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Riot-js简介&quot;&gt;&lt;a href=&quot;#Riot-js简介&quot; class=&quot;headerlink&quot; title=&quot;Riot.js简介&quot;&gt;&lt;/a&gt;Ri
    
    </summary>
    
      <category term="理论学习" scheme="http://chriscindy.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Riot.js" scheme="http://chriscindy.top/tags/Riot-js/"/>
    
  </entry>
  
  <entry>
    <title>跨域请求时多出现一条 OPTIONS 请求的原因及解决办法</title>
    <link href="http://chriscindy.top/post/the-reason-why-an-options-request-appeard-before-cross-origin-request/"/>
    <id>http://chriscindy.top/post/the-reason-why-an-options-request-appeard-before-cross-origin-request/</id>
    <published>2016-07-20T10:19:34.000Z</published>
    <updated>2017-04-21T02:49:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在公司项目中与后端联调时遇到了一个很奇怪的问题，前端发出的 DELETE 方法的 Ajax 请求传到服务端就变成了 OPTIONS 请求。由于服务端没有针对 OPTIONS 请求作回应，此时返回的 http 状态码为 405，意为“方法不被允许”（Method not allowed），DELETE 请求自然也是失败。上网查了一番，原理是触发了 W3C 规定的跨域请求时的安全机制。</p>
<p>W3C 规范中的定义如下：</p>
<blockquote>
<p>To protect resources against cross-origin requests that could not originate from certain user agents before this specification existed a preflight request is made to ensure that the resource is aware of this specification. The result of this request is stored in a preflight result cache.</p>
</blockquote>
<p>大意就是出于安全考虑，保护资源不接受来自特定客户端的跨域请求，存在预请求来提前通知资源。而具体做法呢？看下面：</p>
<blockquote>
<p>It gets slightly more complicated if the resource author wants to be able to handle cross-origin requests using methods other than simple methods. In that case the author needs to reply to a preflight request that uses the OPTIONS method and then needs to handle the actual request that uses the desired method (DELETE in this example) and give an appropriate response.<br>服务端想要处理使用简单方法之外的方法进行的跨域请求时，需要对使用OPTIONS方法的预请求进行响应，然后才能处理实际请求。</p>
</blockquote>
<p>所谓简单方法，是指：</p>
<ul>
<li>只使用 GET, HEAD 或者 POST 请求方法。如果使用 POST 向服务器端传送数据，则数据类型(Content-Type)只能是 application/x-www-form-urlencoded, multipart/form-data 或 text/plain中的一种。</li>
<li>不会使用自定义请求头（类似于 X-Modified 这种）。</li>
</ul>
<p>OPTIONS 是 HTTP/1.1 里的方法，用来获取更多服务器端的信息，是一个不应该对服务器数据造成影响的方法。通过这个方法，客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能。</p>
<p>到这里，我们对整个情况就很明了了：当 Ajax 跨域请求时，如果 HTTP 方法是非简单方法，则客户端即浏览器会发出 OPTIONS 方法的预请求去询问服务端，在得到允许性质的回应后，才会发送真正的请求；如果服务端对预请求拒绝，则真正的 DELETE 请求等不会发出。</p>
<p>看到这里，相信各位也知道如何解决该问题了：服务端对 OPTIONS 预请求给出允许回应。不过，需要注意的是，不应该满足所有的 OPTIONS 请求，否则这一安全措施便形同虚设了。最好是建立一套验证机制，对符合条件的客户端请求给出允许回应。至于如何实现，就靠我们的后端小伙伴啦。有兴趣的朋友可以查看 MDN 上的这篇文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="external">HTTP访问控制(CORS)</a></p>
<p>其他参考文献：</p>
<ul>
<li><a href="http://www.w3.org/TR/cors/" target="_blank" rel="external">W3C Cross-Origin Resource Sharing</a></li>
<li><a href="http://www.tangshuang.net/2271.html" target="_blank" rel="external">jquery ajax 请求中多出现一次 OPTIONS 请求及其解决办法</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在公司项目中与后端联调时遇到了一个很奇怪的问题，前端发出的 DELETE 方法的 Ajax 请求传到服务端就变成了 OPTIONS 请求。由于服务端没有针对 OPTIONS 请求作回应，此时返回的 http 状态码为 405，意为“方法不被允许”（Method not 
    
    </summary>
    
      <category term="解决方案" scheme="http://chriscindy.top/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="HTTP" scheme="http://chriscindy.top/tags/HTTP/"/>
    
      <category term="Ajax" scheme="http://chriscindy.top/tags/Ajax/"/>
    
      <category term="CORS" scheme="http://chriscindy.top/tags/CORS/"/>
    
  </entry>
  
  <entry>
    <title>[译]使用 Riot，ES6 和 Webpack 构建应用</title>
    <link href="http://chriscindy.top/post/%5Btranslation%5D-Building-Apps-with-Riot-ES6-and-Webpack/"/>
    <id>http://chriscindy.top/post/[translation]-Building-Apps-with-Riot-ES6-and-Webpack/</id>
    <published>2016-07-11T03:10:52.000Z</published>
    <updated>2017-04-21T08:42:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>在读完 Muut 上 <a href="https://muut.com/blog/technology/frameworkless-javascript.html" target="_blank" rel="external">Frameworkless JavaScript</a> 这篇博文后，我遇上了 <a href="http://riotjs.com/zh/" target="_blank" rel="external">Riot</a>，请一定先阅读该博文！Muut 的程序员拿出实际行动编写了 <a href="http://riotjs.com/zh/" target="_blank" rel="external">Riot</a>，一个 <a href="https://muut.com/blog/technology/riot-2.0/" target="_blank" rel="external">类似React</a> 的用来构建响应式UI组件的微型库。</p>
<p>阅读Riot的文档时，令我感触最深的是 Riot 竟如此容易理解——相比 React 来说，在 Riot 里需要学习的术语和概念极少（说实话，和 Polymer 和 Angular 等比起来，Riot 也是十分简单易懂的）。</p>
<p>为了有助于学习 Riot，我把自己用 React 编写的 <a href="https://github.com/srackham/flux-backbone-todo" target="_blank" rel="external">flux-backbone-todo</a> 搬运到了用 Riot 编写的 <a href="https://github.com/srackham/riot-todo" target="_blank" rel="external">Riot Todo app</a> 上。这篇博文就是我记录这次重构经历的笔记的合集。</p>
<p>如果觉得文章太长，这里是精简版：</p>
<ol>
<li><p>Riot 确实践行了它最小化的座右铭。Todo 应用的 Riot 版本（未压缩）只有很小的 32 KB。作为对比，React 版本则达到了 964 KB 之多（即使减去在 Riot 版本中未使用到的 Backbone 和 jQuery，React 版本仍然有 600 KB）。不管你怎么看，这都是一个巨大的差异。</p>
</li>
<li><p>Riot 有那种很少见的“刚刚好”的感觉，使用起来非常愉悦。</p>
</li>
<li>Riot 是一个相对较新的方案，因此我没有找到其在大一些的项目中的性能方面的统计数据。在大型项目中 Riot 表现究竟怎样尚未有定论，我希望它能够做的很好。</li>
</ol>
<p>如果你对 Riot 还不熟悉，可以先去浏览一下 <a href="http://riotjs.com/zh/" target="_blank" rel="external">Riot官网</a>——开发文档是第一课。我将列出一些我所学到的但是阅读文档时不一定很明显易懂的内容，而不会去讨论 Riot 是如何工作的。</p>
<h2 id="在-Riot-中使用-ES6"><a href="#在-Riot-中使用-ES6" class="headerlink" title="在 Riot 中使用 ES6"></a>在 Riot 中使用 ES6</h2><p><a href="https://github.com/srackham/riot-todo" target="_blank" rel="external">示例的应用</a>采用 ES6 编写，我使用 <a href="http://6to5.org" target="_blank" rel="external">6to5</a> 转译器将其转换为 ES5 代码，使用 <a href="http://webpack.github.io" target="_blank" rel="external">Webpack</a> 将编译后的代码以及需要的库一起打包。这种方式使得联结 JavaScript 模块成为必要——当你理解最新的 ES6 中 <code>import</code> 和 <code>export</code> 表述的优势时（看这个<a href="https://github.com/srackham/riot-todo/blob/master/src/index.js" target="_blank" rel="external">示例</a>），你就会知道使用 ES6 编写代码是非常棒的。</p>
<p>Webpack通过<a href="https://github.com/srackham/riot-todo/blob/master/webpack.config.js" target="_blank" rel="external">配置</a>可以使用 <code>6to5 loader</code> 将 ES6 源码自动转换成 CommonJS 格式的 ES5 模块，再将其打包至一个单独的 <code>bundle.js</code> 文件。</p>
<h2 id="为什么我不使用-Riot-的-tag-文件"><a href="#为什么我不使用-Riot-的-tag-文件" class="headerlink" title="为什么我不使用 Riot 的 .tag 文件"></a>为什么我不使用 Riot 的 <code>.tag</code> 文件</h2><p>Riot 标签文件是指包含 HTML 标记以及 JavaScript UI 逻辑的 HTML 模板。如果你已经浏览过了上面提到的 <a href="https://github.com/srackham/riot-todo" target="_blank" rel="external">Todo应用</a>，你可能会疑惑标签文件在哪里——答案是我已经不再使用它们，并且更喜欢用 JavaScript 来替代之。去除 <code>.tag</code> 文件简化了我的编码、加工和工作流程。对我来说，标签文件的复杂性和局限性大于它任何可以感知到的优点。</p>
<p>这并不是对 Riot 的一种批判。对标签文件来说，灵活的地方在于它完全可选而非强制使用，在此记录我不使用它的原因。</p>
<p>当你审视编译后的 JavaScript 代码时，你会看到 Riot 标签文件其实是一层轻微的语法糖.</p>
<ul>
<li>它添加了额外的概念层——新的或者比较新的语法和语义需要学习。</li>
<li>它添加了额外的编译步骤。</li>
<li>标签文件编译器指定了你可以使用的语言和模板（CoffeeScript、ES6和Jade），这有悖于“使用你最喜欢的工具”的理念。</li>
<li>标签构造主体的逻辑脱离上下文：<ul>
<li>这使得标签文件无法被编辑器/IDE 的代码检测以及其他的工具处理</li>
<li>涉及 <code>this</code> 时，脱离上下文意味着代码不是合法的 JavaScript 并且在编辑器/IDE 中会报错</li>
</ul>
</li>
<li>目前没有对模块化（CommonJS，AMD）标签文件编译为普通 JavaScript 的支持。</li>
<li>标签文件需要构建工具（比如 Webpack 和 Browserify）直接使用标签转换器来进行转换。</li>
<li><p>类似 ES6 的构造方法很棒但它们不是合法的 JavaScript 并且很可能总是成为持续混乱（语法和语义上）的来源。你可以使用 ES6 的<em>箭头函数</em>以几乎相同的简洁程度来获得相同的语义（拥有词法作用域的 <code>this</code>），举例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.add = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</div><div class="line">	<span class="keyword">var</span> input = e.target[<span class="number">0</span>]</div><div class="line">	<span class="keyword">this</span>.items.push(input.value)</div><div class="line">	input.value = <span class="string">''</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这里有一个使用 ES6 模板字符串和箭头函数的 ES6 形式的 JavaScript 标签文件的<a href="https://github.com/srackham/riot-todo/blob/0.1.1/src/tags.js" target="_blank" rel="external">例子</a>。</p>
<p>ES6 模板字符串提高了标签 HTML 模板的可读性。相似的，如果你使用的是 CoffeeScript，那么你可以使用 CoffeeScript 块字符串。<a href="http://facebook.github.io/jsx/" target="_blank" rel="external">JSX</a> 是另一种可选项——React 的 JSX 转换器可以经过修改然后生成字符串文本，这样你就可以获得现有的 JSX 工具的支持。</p>
<h2 id="Riot和React的基本区别"><a href="#Riot和React的基本区别" class="headerlink" title="Riot和React的基本区别"></a>Riot和React的基本区别</h2><p>最重要的区别在于 UI 标记模板是如何声明的：</p>
<ul>
<li>在 React 中 UI 标记模板是在你的 JavaScript 源码中生成的（使用 JSX 语言的扩展）。</li>
<li>Riot 则反转了 React 的模型，将标记和逻辑都放在 HTML（标签）文件中。</li>
</ul>
<p>这种反转的结果是 React 模板 DSL（领域特定语言）就是 JavaScript，而 Riot 依赖自定义的模板 DSL（采用自定义标签实现）。下面是两个简化的从一个 todo 事项的数组中生成一个列表的例子，第一个采用 React JavaScript编写，第二个是等价的 Riot 标签标记形式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">  todos.map(todo =&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">TodoItemComponent</span> <span class="attr">todo</span>=<span class="string">&#123;todo&#125;</span> /&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>)</div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">each</span>=<span class="string">"&#123;todo in todos&#125;"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">todo-item</span> <span class="attr">todo</span>=<span class="string">"&#123;todo&#125;"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<p>第一个例子中使用了 JavaScript 的 <code>map</code> 函数来生成一个 <code>&lt;li&gt;</code> 元素的列表；第二个例子则使用了 Riot 自定义的 <code>each</code> 模板属性。</p>
<p>Steve Luscher 在这个<a href="https://www.youtube.com/watch?v=rI0GQc__0SM#t=1325" target="_blank" rel="external">视频</a>的结尾解释了为何他认为 JavaScript 比自定义模板 DSL 更优秀——你不仅需要学习一门自定义的 DSL，而且还要拘泥于这套 DSL 提供的特性的束缚。对于像上面这样较小的普通用例来说，两种方式其实没太多选择余地，但是在编写更大的高度动态化的 UI 组件时，React 的 JavaScript 方式的威力和灵活性就明显更优越了。</p>
<h2 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h2><h3 id="避免自关闭的XHTML风格的标签"><a href="#避免自关闭的XHTML风格的标签" class="headerlink" title="避免自关闭的XHTML风格的标签"></a>避免自关闭的XHTML风格的标签</h3><p>不要用<code>/&gt;</code>来关闭标签，因为它不总是立刻就能关闭标签。当以 HTML5 元素对待时，<code>&lt;foo /&gt;</code> 表示<code>&lt;foo&gt;</code>（然而在 XHTML 中<code>&lt;foo /&gt;</code>表示<code>&lt;foo&gt;&lt;/foo&gt;</code>），换言之，HTML5 会忽略<code>/</code>字符。有关这个话题可以在 <a href="http://stackoverflow.com/questions/9845011/are-custom-elements-valid-html5/9845124#9845124" target="_blank" rel="external">Stackoverflow</a> 上查看更多讨论。还可以查看下面两处内容：</p>
<ul>
<li><a href="http://riotjs.com/forum/#!/using:closing-html5-tags-with-" target="_blank" rel="external">使用<code>/&gt;</code>关闭HTML5标签可能造成无法预料的结果</a></li>
<li><a href="http://riotjs.com/forum/#!/using:misplaced-form-end-tag" target="_blank" rel="external">放错位置的表单结束标签</a></li>
</ul>
<h3 id="绑定标签事件处理器到-this-上"><a href="#绑定标签事件处理器到-this-上" class="headerlink" title="绑定标签事件处理器到 this 上"></a>绑定标签事件处理器到 this 上</h3><p>绑定标签事件处理器到 this 上，以确保这些处理器总是和标签文本一起清除（可选的方式是使用约定俗成的<code>var self = this</code>）。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  dispatcher.trigger(dispatcher.CLEAR_TODOS);</div><div class="line">&#125;.bind(<span class="keyword">this</span>);</div></pre></td></tr></table></figure>
<p>使用 ES6 中的词法作用域绑定的箭头函数也可以获得相同的效果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.clear = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</div><div class="line">  dispatcher.trigger(dispatcher.CLEAR_TODOS);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="关于循环项"><a href="#关于循环项" class="headerlink" title="关于循环项"></a>关于循环项</h3><p>使用<code>each={item in items}</code>结构将当前的循环项目传递给自定义的子标签。在下面的例子中，自定义的<code>todo-item</code>标签内的代码可以使用<code>opts.todo</code>来获取当前的 todo 项：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">each</span>=<span class="string">"&#123;todo in opts.store.todos&#125;"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">todo-item</span> <span class="attr">store</span>=<span class="string">"&#123;parent.opts.store&#125;"</span> <span class="attr">todo</span>=<span class="string">"&#123;todo&#125;"</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="命名空间事件名称"><a href="#命名空间事件名称" class="headerlink" title="命名空间事件名称"></a>命名空间事件名称</h3><p>使用命名空间加冒号的约定来组织应用的事件名称，比如<code>admin:edit</code>，<code>admin:delete</code>，<code>admin:new</code>等。</p>
<h3 id="可以在-CSS-文件中使用自定义标签"><a href="#可以在-CSS-文件中使用自定义标签" class="headerlink" title="可以在 CSS 文件中使用自定义标签"></a>可以在 CSS 文件中使用自定义标签</h3><p>自定义标签最终会被渲染生成到 DOM 中，因此它们可以使用在 CSS 选择器和 DOM 审查中使用，这里是一个<a href="https://github.com/srackham/riot-todo/blob/master/dist/index.css" target="_blank" rel="external">例子</a>。</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>当用 Webpack 打包时你需要使用<a href="https://github.com/srackham/riot-todo/blob/master/webpack.config.js" target="_blank" rel="external">开发工具 source-map 配置选项</a>来为你打包后的应用生成 <a href="http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/" target="_blank" rel="external">source map</a> 文件。这使得你可以在 ES6 的源码文件中进行调试。</p>
<p>当需要浏览和调试源码时，打开浏览器的 <em>Sources 窗口</em>然后定位到<code>webpack:///.</code>文件夹：</p>
<ul>
<li>在 Firefox 中：打开 Debugger（Ctrl+Shift+S）。</li>
<li>在 Google Chrome 中：打开 Console（Ctrl+Shift+J）然后点击 <em>Sources</em> 标签来查看源码面板。</li>
</ul>
<p>我不是很喜欢调试程序和设置断点——大多数情况下我仅仅会有策略地在代码中放置暂时性的<code>console.log()</code>。</p>
<h2 id="未来蓝图"><a href="#未来蓝图" class="headerlink" title="未来蓝图"></a>未来蓝图</h2><p>Riot（类似 React）是一个 UI 库而不是一个框架。这非常棒（相对于大包大揽的框架来说，我更喜欢小而精的库的集合），但是对于具有一定复杂度的应用来说就需要条理清晰的高级的结构（一个体系结构）来提高可伸缩性、可发展性和可维护性。<a href="https://www.npmjs.com/package/flux" target="_blank" rel="external">Flux</a> 为类似React的应用增加了体系结构的选择。我喜欢 Flux，因为它很容易理解并且它能给人一种很直观的感觉（并非出于任何理论上的信仰）。<a href="https://github.com/srackham/riot-todo" target="_blank" rel="external">Riot Todo app</a> 使用了名为 <a href="https://github.com/jimsparkman/RiotControl" target="_blank" rel="external">RiotControl</a> 的 Flux 风格的 dispatcher（经过轻微修改）来实现 Flux 体系结构。</p>
<blockquote><p>原文出处：</p>
<footer><strong>srackham</strong><cite><a href="http://blog.srackham.com/posts/riot-es6-webpack-apps/" target="_blank" rel="external">Building Apps with Riot, ES6 and Webpack</a></cite></footer></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在读完 Muut 上 &lt;a href=&quot;https://muut.com/blog/technology/frameworkless-javascript.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Frameworkless JavaScri
    
    </summary>
    
      <category term="技术研究" scheme="http://chriscindy.top/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Riot.js" scheme="http://chriscindy.top/tags/Riot-js/"/>
    
  </entry>
  
</feed>
